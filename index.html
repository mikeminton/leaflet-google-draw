<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <title>Leaflet + Google + Draw + UK Searches</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Fullscreen -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.css">
  <script src="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.js"></script>

  <!-- Leaflet.Geoman (drawing/editing) -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css">
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js"></script>

  <!-- GoogleMutant (Leaflet grid layer for Google) -->
  <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.15.0/dist/Leaflet.GoogleMutant.js"></script>

  <!-- Leaflet Control Geocoder (Nominatim) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css">
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <!-- Proj4 for OSGB ↔ WGS84 transforms -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100vh; }
    .toolbar {
      position: absolute; z-index: 1000; top: 10px; left: 10px;
      background: #fff; border-radius: 10px; padding: 8px 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 14px system-ui, sans-serif;
      display: grid; gap: 6px; grid-template-columns: 1fr auto;
      min-width: 320px;
    }
    .toolbar-row { display: grid; gap: 6px; grid-template-columns: 1fr auto; grid-column: 1 / -1; }
    .toolbar input { padding: 6px 8px; border: 1px solid #ddd; border-radius: 8px; }
    .toolbar button { padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; background: #f7f7f7; cursor: pointer; }
    .toolbar button:hover { background: #eee; }
    .info {
      position: absolute; z-index: 1000; right: 10px; bottom: 10px;
      background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif;
      min-width: 280px; max-width: 360px;
    }
    .info h4 { margin: 0 0 6px 0; font-size: 14px; }
    .info .row { margin: 4px 0; }
    .info code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }
    .hidden { display: none; }
  </style>
</head>
<body>
<div id="map"></div>

<!-- Top toolbar -->
<div class="toolbar">
  <!-- Address/postcode search (also have the geocoder control on map) -->
  <div class="toolbar-row">
    <input id="search-q" type="text" placeholder="Search address or postcode (UK)…" />
    <button id="btn-search">Search</button>
  </div>
  <!-- Lat/Lon -->
  <div class="toolbar-row">
    <input id="search-latlon" type="text" placeholder="Lat, Lon (e.g., 52.677027, -2.773167)" />
    <button id="btn-latlon">Go</button>
  </div>
  <!-- Easting/Northing (OSGB36 / EPSG:27700) -->
  <div class="toolbar-row">
    <input id="search-en" type="text" placeholder="Easting, Northing (EPSG:27700)" />
    <button id="btn-en">Go</button>
  </div>
  <!-- Export / Import -->
  <div class="toolbar-row">
    <button id="btn-export">Export GeoJSON</button>
    <button id="btn-import">Import</button>
    <input id="file-import" type="file" accept=".json,.geojson" class="hidden">
  </div>
</div>

<!-- Pin info panel -->
<div class="info" id="info">
  <h4>Pin info</h4>
  <div class="row" id="addr">Address: <em>—</em></div>
  <div class="row">Lat/Lon: <code id="latlon">—</code></div>
  <div class="row">Easting/Northing: <code id="en">—</code></div>
</div>

<!-- Google Maps JS (async, no callback) -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAdHcFCZWzjEOj98oEn5AfufQMR0p9VgLA&v=weekly&loading=async"></script>

<script type="module">
  // ---------- Config ----------
  const centre = [52.677027, -2.773167]; // 29 Green Lane, SY3 0NS
  const isNumber = v => typeof v === 'number' && !isNaN(v) && isFinite(v);

  // Define OSGB36 (EPSG:27700)
  proj4.defs('EPSG:27700', '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs');
  const WGS84 = 'EPSG:4326';
  const OSGB  = 'EPSG:27700';

  // ---------- Basemaps ----------
  const esriImagery = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 20, attribution: "Imagery © Esri" }
  );
  const esriLabels = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 20, attribution: "Labels © Esri" }
  );
  const osmStreets = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    { maxZoom: 20, attribution: "© OpenStreetMap contributors" }
  );

  // Build Leaflet map with fallback first (so users see something immediately)
  const map = L.map("map", {
    center: centre,
    zoom: 19,
    layers: [esriImagery, esriLabels],
    fullscreenControl: true
  });

  // Leaflet Geocoder control (Nominatim)
  L.Control.geocoder({
    defaultMarkGeocode: false,
    placeholder: 'Search…'
  }).on('markgeocode', e => {
    const { center, name, bbox } = e.geocode;
    setPin(center.lat, center.lng, name);
    if (bbox) map.fitBounds(bbox);
  }).addTo(map);

  // Marker for the pin
  let pin = L.marker(centre).addTo(map).bindPopup("29 Green Lane, SY3 0NS").openPopup();

  // Info panel elements
  const elAddr = document.getElementById('addr');
  const elLatLon = document.getElementById('latlon');
  const elEN = document.getElementById('en');

  // Update info panel (reverse geocode + coord display)
  async function updateInfo(lat, lon, labelHint = '') {
    const latStr = lat.toFixed(6), lonStr = lon.toFixed(6);
    elLatLon.textContent = `${latStr}, ${lonStr}`;

    // Lat/Lon -> Easting/Northing
    const [E, N] = proj4(WGS84, OSGB, [lon, lat]);
    elEN.textContent = `${Math.round(E)}, ${Math.round(N)}`;

    // Reverse geocode (Nominatim)
    try {
      const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latStr}&lon=${lonStr}&addressdetails=1&zoom=18&accept-language=en-GB`;
      const resp = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const data = await resp.json();
      const addr = data?.display_name || labelHint || 'Unknown location';
      elAddr.innerHTML = `Address: <em>${addr}</em>`;
      pin.setPopupContent(addr);
    } catch {
      elAddr.innerHTML = `Address: <em>${labelHint || 'Lookup failed'}</em>`;
    }
  }

  // Create / move the pin and update info
  function setPin(lat, lon, labelHint = '') {
    if (!isNumber(lat) || !isNumber(lon)) return;
    pin.setLatLng([lat, lon]);
    pin.addTo(map).openPopup();
    map.setView([lat, lon], Math.max(map.getZoom(), 18));
    updateInfo(lat, lon, labelHint);
  }

  // Map click → move pin + info
  map.on('click', (e) => {
    setPin(e.latlng.lat, e.latlng.lng, 'Dropped pin');
  });

  // ---------- Google base (async ready) ----------
  async function ensureGoogle() {
    for (let i = 0; i < 400; i++) {
      if (window.google?.maps?.importLibrary) break;
      await new Promise(r => setTimeout(r, 25));
    }
    if (!window.google?.maps?.importLibrary) throw new Error('Google Maps JS API not ready');
    await google.maps.importLibrary("maps");
  }

  try {
    await ensureGoogle();
    const gRoad   = L.gridLayer.googleMutant({ type: "roadmap",   maxZoom: 21 });
    const gHybrid = L.gridLayer.googleMutant({ type: "hybrid",    maxZoom: 21 });
    const gSat    = L.gridLayer.googleMutant({ type: "satellite", maxZoom: 21 });

    // Show Google Hybrid on top
    map.addLayer(gHybrid);

    const baseMaps = {
      "Google Roadmap": gRoad,
      "Google Hybrid":  gHybrid,
      "Google Satellite": gSat,
      "Esri Satellite (fallback)": esriImagery,
      "OSM Streets (fallback)": osmStreets
    };
    const overlays = { "Esri Labels (for Esri Hybrid)": esriLabels };
    L.control.layers(baseMaps, overlays, { collapsed: false }).addTo(map);

  } catch (e) {
    console.warn('Google base unavailable, staying on Esri/OSM.', e);
    L.control.layers(
      { "Esri Satellite": esriImagery, "OSM Streets": osmStreets },
      { "Esri Labels (Hybrid)": esriLabels },
      { collapsed: false }
    ).addTo(map);
  }

  // ---------- Toolbar actions ----------
  // Postcode/address search (manual input)
  document.getElementById('btn-search').onclick = async () => {
    const q = document.getElementById('search-q').value.trim();
    if (!q) return;
    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&countrycodes=gb&limit=1&addressdetails=1&accept-language=en-GB`;
    try {
      const r = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const j = await r.json();
      if (j && j.length) {
        const { lat, lon, display_name, boundingbox } = j[0];
        setPin(parseFloat(lat), parseFloat(lon), display_name);
        if (boundingbox) {
          const bb = [[+boundingbox[0], +boundingbox[2]],[+boundingbox[1], +boundingbox[3]]];
          map.fitBounds(bb, { maxZoom: 19 });
        }
      } else {
        alert('No results.');
      }
    } catch {
      alert('Search failed (network?).');
    }
  };

  // Lat/Lon search
  document.getElementById('btn-latlon').onclick = () => {
    const raw = document.getElementById('search-latlon').value.trim();
    if (!raw) return;
    const parts = raw.split(/[,\s]+/).filter(Boolean);
    if (parts.length !== 2) return alert('Use "lat, lon" (e.g., 52.677027, -2.773167).');
    const lat = parseFloat(parts[0]), lon = parseFloat(parts[1]);
    if (!isNumber(lat) || !isNumber(lon)) return alert('Invalid numbers.');
    setPin(lat, lon, 'Lat/Lon');
  };

  // Easting/Northing (EPSG:27700) search
  document.getElementById('btn-en').onclick = () => {
    const raw = document.getElementById('search-en').value.trim();
    if (!raw) return;
    const parts = raw.split(/[,\s]+/).filter(Boolean);
    if (parts.length !== 2) return alert('Use "Easting, Northing" (EPSG:27700).');
    const E = parseFloat(parts[0]), N = parseFloat(parts[1]);
    if (!isNumber(E) || !isNumber(N)) return alert('Invalid numbers.');
    const [lon, lat] = proj4(OSGB, WGS84, [E, N]); // returns [lon, lat]
    setPin(lat, lon, `OSGB36: ${Math.round(E)}, ${Math.round(N)}`);
  };

  // Export drawings
  document.getElementById('btn-export').onclick = () => {
    const feats = [];
    map.eachLayer(l => {
      if (l.pm && l.toGeoJSON) {
        const gj = l.toGeoJSON();
        if (gj.type === 'Feature') feats.push(gj);
        else if (gj.type === 'FeatureCollection') feats.push(...gj.features);
      }
    });
    const fc = { type: 'FeatureCollection', features: feats };
    const blob = new Blob([JSON.stringify(fc, null, 2)], { type: 'application/json' });
    const a = Object.assign(document.createElement('a'), { href: URL.createObjectURL(blob), download: 'drawings.geojson' });
    a.click(); URL.revokeObjectURL(a.href);
  };

  // Import drawings
  document.getElementById('btn-import').onclick = () => document.getElementById('file-import').click();
  document.getElementById('file-import').onchange = async (ev) => {
    const file = ev.target.files[0]; if (!file) return;
    try {
      const text = await file.text();
      const gj = JSON.parse(text);
      const layer = L.geoJSON(gj, { style: { color: '#00AEEF', weight: 2, fillOpacity: 0.18 } }).addTo(map);
      try { map.fitBounds(layer.getBounds(), { maxZoom: 19 }); } catch {}
    } catch {
      alert('Invalid GeoJSON.');
    }
  };

  // Drawing UX
  map.pm.addControls({
    position: "topleft",
    drawMarker: true,
    drawPolyline: true,
    drawRectangle: true,
    drawPolygon: true,
    drawCircle: true,
    drawCircleMarker: true,
    editMode: true,
    dragMode: true,
    cutPolygon: true,
    removalMode: true
  });
  map.pm.setGlobalOptions({ snapDistance: 20, continueDrawing: false });

  // Initial info populate
  (async () => { await updateInfo(centre[0], centre[1], '29 Green Lane, SY3 0NS'); })();
</script>

<noscript>Enable JavaScript to view the map.</noscript>
</body>
</html>
