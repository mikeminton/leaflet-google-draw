<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <title>Leaflet + Multi‑Engine Routing — Forced Alternatives (Avoids + Detour Vias)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Fullscreen -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.css">
  <script src="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.js"></script>

  <!-- Leaflet.Geoman -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css">
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js"></script>

  <!-- GoogleMutant -->
  <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.15.0/dist/Leaflet.GoogleMutant.js"></script>

  <!-- Proj4 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>

  <!-- Turf.js -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100vh; position: relative; }

    .toolbar {
      position: absolute; z-index: 1000; top: 10px; left: 60px; right: 10px;
      background: #fff; border-radius: 12px; padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,.18); font: 14px system-ui, sans-serif;
      display: flex; align-items: center; gap: 8px;
      flex-wrap: nowrap; white-space: nowrap;
      overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; scrollbar-width: thin;
    }
    .toolbar select, .toolbar input, .toolbar button, .toolbar label {
      padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; flex: 0 0 auto; cursor: pointer;
    }
    .toolbar label { display:flex; align-items:center; gap:6px; padding:4px 8px; }
    #q { min-width: 280px; flex: 1 1 360px; }
    .mini { width: 200px; }
    .toolbar .spacer { width: 6px; flex: 0 0 auto; }

    /* Leaflet controls above panels */
    .leaflet-control { z-index: 1200 !important; }
    .leaflet-top.leaflet-right .leaflet-control-layers { margin-top: 120px !important; }

    /* Info (BR) */
    .info, .metrics, .routebox { background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif; }
    .info { position: absolute; z-index: 1000; right: 10px; bottom: 50px; min-width: 280px; max-width: 360px; }
    .metrics { position: absolute; z-index: 1000; left: 10px; bottom: 50px; min-width: 260px; max-width: 380px; }
    .routebox { position: absolute; z-index: 1000; left: 410px; bottom: 50px; min-width: 380px; max-width: 620px; }

    .info h4, .metrics h4, .routebox h4 { margin: 0 0 6px 0; font-size: 14px; }
    .row { margin: 4px 0; }
    code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }

    .metrics .btn, .routebox button {
      padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; background: #f7f7f7; cursor: pointer;
    }
    .metrics .btn + .btn { margin-left: 6px; }

    .route-item { display:flex; align-items:center; gap:8px; padding:6px 8px; border:1px solid #eee; border-radius:8px; margin:6px 0; cursor:pointer; }
    .route-swatch { width:14px; height:14px; border-radius:3px; border:1px solid #bbb; }
    .route-item.active { border-color:#bbb; background:#fafafa; }
    .provider-tag { font-size: 11px; opacity:.8; padding:2px 6px; border:1px solid #ddd; border-radius:6px; }

    .via-chip { display:inline-flex; align-items:center; gap:4px; padding:2px 6px; border:1px solid #ddd; border-radius:14px; margin-right:6px; }
    .via-chip button { border:none; background:transparent; cursor:pointer; }

    @media (max-width: 1100px) { .routebox { left: 10px; bottom: 10px; max-width: 360px; } }

    /* Street View panel */
    #sv-panel { position: absolute; z-index: 1100; right: 10px; bottom: 10px; width: 420px; height: 300px;
      background: #fff; border-radius: 10px; box-shadow: 0 2px 12px rgba(0,0,0,.18); display: none; overflow: hidden; border: 1px solid #ddd; resize: both; }
    #sv-header { height: 36px; display:flex; align-items:center; justify-content:space-between; padding: 0 10px; border-bottom: 1px solid #eee; background:#fafafa; font: 13px system-ui; }
    #sv-title { font-weight: 600; }
    #sv-actions button { margin-left: 6px; padding: 4px 8px; border: 1px solid #ddd; background:#fff; border-radius: 6px; cursor: pointer; }
    #pano { width: 100%; height: calc(100% - 36px); }
  </style>
</head>
<body>
<div id="map">
  <div class="toolbar" id="ui-toolbar">
    <select id="mode" title="Search mode">
      <option value="postcode">Postcode / Address</option>
      <option value="latlon">Lat, Lon</option>
      <option value="en">Easting, Northing</option>
    </select>
    <input id="q" type="text" placeholder="SY3 0NS  |  52.677027, -2.773167  |  349000, 306000" />
    <button id="go">Search</button>

    <span class="spacer"></span>

    <button id="btn-export" title="Download drawings as GeoJSON">Export</button>
    <button id="btn-import" title="Load drawings from GeoJSON">Import</button>
    <input id="file-import" type="file" accept=".json,.geojson" style="display:none">

    <span class="spacer"></span>

    <button id="btn-edit-all" title="Enable edit mode for all shapes">Edit All</button>
    <button id="btn-drag"     title="Enable drag mode for shapes">Drag Mode</button>
    <button id="btn-finish"   title="Disable edit/drag modes">Finish Edit</button>

    <span class="spacer"></span>

    <button id="btn-sv-center" title="Open Street View at map centre">Street View here</button>
    <button id="btn-sv-pin" title="Open Street View at last pin">Street View at Pin</button>

    <span class="spacer"></span>

    <!-- Routing controls -->
    <input id="route-start" class="mini" type="text" placeholder="Start: address / 52.6,-2.7 / 349000,306000" />
    <input id="route-end"   class="mini" type="text" placeholder="End: address / 52.7,-2.8 / 340000,300000" />
    <select id="route-mode" title="Travel mode">
      <option value="driving">Driving</option>
      <option value="walking">Walking</option>
      <option value="cycling">Cycling</option>
    </select>
    <label title="Prefer unusual paths"><input type="checkbox" id="prefer-odd"> Explore off‑beat</label>
    <label title="Avoid motorways (Google only)"><input type="checkbox" id="avoid-hwy"> Avoid highways</label>
    <label title="Avoid tolls (Google only)"><input type="checkbox" id="avoid-tolls"> Avoid tolls</label>
    <label title="Avoid ferries"><input type="checkbox" id="avoid-ferries"> Avoid ferries</label>
    <select id="detour-level" title="Generate artificial detour vias">
      <option value="none">No detours</option>
      <option value="light">Detour: Light</option>
      <option value="medium" selected>Detour: Medium</option>
      <option value="heavy">Detour: Heavy</option>
    </select>
    <button id="btn-pin-start" title="Use current pin as Start">Pin→Start</button>
    <button id="btn-pin-end" title="Use current pin as End">Pin→End</button>
    <button id="btn-swap" title="Swap start/end">Swap</button>
    <button id="btn-route" title="Calculate routes">Route</button>
    <button id="btn-clear-route" title="Clear routes">Clear</button>
    <label title="Use Google Directions (more alternatives)"><input type="checkbox" id="use-google" checked> Use Google</label>
  </div>

  <!-- Routes panel -->
  <div class="routebox" id="routebox">
    <h4>ROUTES:</h4>
    <div class="row">Mode: <code id="r-mode">—</code></div>
    <div class="row">Vias (Ctrl+Click to add): <span id="vias"></span> <button id="clear-vias">Clear vias</button></div>
    <div id="r-list" class="row"></div>
    <div class="row" style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
      <button id="btn-use-selected" title="Add the selected route to drawings">Use Selected</button>
      <button id="btn-copy-selected" title="Copy selected route coordinates">Copy Coords</button>
      <button id="btn-zoom-all" title="Zoom to all routes">Zoom All</button>
    </div>
    <div class="row" style="opacity:.8">
      Tip: if providers return only one option, toggle <b>Explore off‑beat</b> and raise <b>Detour</b> level.
    </div>
  </div>

  <!-- Info -->
  <div class="info" id="info">
    <h4>LOCATION INFORMATION:</h4>
    <div class="row">Postcode: <code id="postcode">—</code></div>
    <div class="row">Lat/Lon: <code id="latlon">—</code></div>
    <div class="row">Easting/Northing: <code id="en">—</code></div>
    <div class="row" style="opacity:.8">Shift+Click: drop pin • Ctrl+Click: add via • Alt+Click: Street View • Right‑click: set Start/End</div>
  </div>

  <!-- Street View -->
  <div id="sv-panel">
    <div id="sv-header">
      <div id="sv-title">Street View</div>
      <div id="sv-actions">
        <button id="sv-popout" title="Open in Google Maps">Open in Maps</button>
        <button id="sv-close" title="Close Street View">Close</button>
      </div>
    </div>
    <div id="pano"></div>
  </div>
</div>

<!-- Runtime Google API key loader (Option B) -->
<script id="gmaps-loader">
(function () {
  const STORAGE = 'gmapsApiKey';
  const paramKey = new URL(location.href).searchParams.get('gmaps');
  if (paramKey) localStorage.setItem(STORAGE, paramKey);
  const savedKey = localStorage.getItem(STORAGE);
  function inject(k) {
    if (!k) return;
    const s = document.createElement('script');
    s.src = 'https://maps.googleapis.com/maps/api/js?key=' + encodeURIComponent(k) + '&v=weekly&loading=async';
    s.async = true; s.defer = true;
    document.head.appendChild(s);
  }
  if (savedKey) { inject(savedKey); return; }
  const ui = document.createElement('div');
  ui.style.cssText = 'position:fixed;z-index:2000;left:50%;top:12px;transform:translateX(-50%);background:#fff;padding:10px 12px;border:1px solid #ddd;border-radius:10px;box-shadow:0 2px 12px rgba(0,0,0,.15);font:13px system-ui';
  ui.innerHTML = `
    <b>Google Maps API key needed</b>
    <div style="margin-top:6px;display:flex;gap:6px;align-items:center;">
      <input id="gmaps-key-input" type="password" placeholder="Paste key…" style="width:280px;padding:6px 8px;border:1px solid #ccc;border-radius:8px;">
      <button id="gmaps-key-save" style="padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#f7f7f7;cursor:pointer;">Save</button>
      <button id="gmaps-key-cancel" style="padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer;">Dismiss</button>
    </div>
    <div style="margin-top:6px;opacity:.75">Or use <code>?gmaps=YOUR_KEY</code>. Stored only in this browser.</div>`;
  document.addEventListener('DOMContentLoaded', () => {
    document.body.appendChild(ui);
    document.getElementById('gmaps-key-save')?.addEventListener('click', () => {
      const val = document.getElementById('gmaps-key-input').value.trim();
      if (!val) return alert('Paste your Google Maps JavaScript API key.');
      localStorage.setItem(STORAGE, val); ui.remove(); inject(val);
    });
    document.getElementById('gmaps-key-cancel')?.addEventListener('click', () => ui.remove());
  });
  window.__clearGMapsKey = () => { localStorage.removeItem(STORAGE); location.reload(); };
})();
</script>

<script type="module">
  // Config & helpers
  const centre = [52.677027, -2.773167];
  proj4.defs('EPSG:27700', '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs');
  const WGS84 = 'EPSG:4326', OSGB='EPSG:27700';
  const byId = id => document.getElementById(id);
  const isNum = v => typeof v === 'number' && isFinite(v) && !isNaN(v);

  // Base maps
  const esriImagery = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {maxZoom:20, attribution:"Imagery © Esri"});
  const esriLabels  = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}", {maxZoom:20, attribution:"Labels © Esri"});
  const osmStreets  = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {maxZoom:20, attribution:"© OpenStreetMap contributors"});

  const map = L.map("map", { center: centre, zoom: 19, layers: [esriImagery, esriLabels], fullscreenControl: true });

  function blockEventsFor(selector) {
    document.querySelectorAll(selector).forEach(el => { L.DomEvent.disableClickPropagation(el); L.DomEvent.disableScrollPropagation(el); });
  }
  blockEventsFor('#ui-toolbar, #metrics, #info, #sv-panel, #routebox');
  blockEventsFor('.leaflet-control-container');

  // Pin
  let pin = L.marker(centre).addTo(map).bindPopup("SY3 0NS").openPopup();

  // Google layers (async)
  async function ensureGoogle() {
    for (let i=0;i<400;i++) { if (window.google?.maps?.importLibrary) break; await new Promise(r=>setTimeout(r,25)); }
    if (!window.google?.maps?.importLibrary) throw new Error('Google Maps JS API not ready');
    await google.maps.importLibrary("maps");
  }
  try {
    await ensureGoogle();
    const gRoad = L.gridLayer.googleMutant({ type: "roadmap", maxZoom: 21 });
    const gHybrid = L.gridLayer.googleMutant({ type: "hybrid", maxZoom: 21 });
    const gSat = L.gridLayer.googleMutant({ type: "satellite", maxZoom: 21 });
    map.addLayer(gHybrid);
    const baseMaps = { "Google Roadmap": gRoad, "Google Hybrid": gHybrid, "Google Satellite": gSat, "Esri Satellite (fallback)": esriImagery, "OSM Streets (fallback)": osmStreets };
    const overlays = { "Esri Labels (for Esri Hybrid)": esriLabels };
    L.control.layers(baseMaps, overlays, { collapsed: false }).addTo(map);
  } catch (e) {
    console.warn('Google base unavailable', e);
    L.control.layers({ "Esri Satellite": esriImagery, "OSM Streets": osmStreets }, { "Esri Labels (Hybrid)": esriLabels }, { collapsed: false }).addTo(map);
  }

  // Search
  const elPostcode = byId('postcode'), elLatLon = byId('latlon'), elEN = byId('en');
  function normalizeUKPostcode(str){ if(!str) return null; const s=str.toUpperCase().replace(/\s+/g,''); return /^[A-Z]{1,2}\d[A-Z\d]?\d[A-Z]{2}$/.test(s)?s:null; }
  async function updateInfo(lat,lon){
    const latStr=lat.toFixed(6), lonStr=lon.toFixed(6);
    elLatLon.textContent=`${latStr}, ${lonStr}`;
    const [E,N]=proj4(WGS84,OSGB,[lon,lat]); elEN.textContent=`${Math.round(E)}, ${Math.round(N)}`;
    let pc='—'; try{ const pr=await fetch(`https://api.postcodes.io/postcodes?lon=${lonStr}&lat=${latStr}&limit=1`); const pj=await pr.json(); pc=pj?.result?.[0]?.postcode||'—'; }catch{}
    elPostcode.textContent=pc; pin.setPopupContent(pc);
  }
  function setPin(lat,lon,recenter=false){ if(!isNum(lat)||!isNum(lon)) return; pin.setLatLng([lat,lon]).addTo(map).openPopup(); if(recenter) map.setView([lat,lon], Math.max(map.getZoom(),18)); updateInfo(lat,lon); }

  // Drawing & metrics (unchanged core)
  const defaultStyle={color:"#00AEEF",weight:2,fillOpacity:0.18}, activeStyle={color:"#007ACC",weight:2,fillOpacity:0.20};
  map.pm.setGlobalOptions({ snappable:true, snapDistance:20, allowSelfIntersection:false, continueDrawing:false, finishOn:'dblclick' });
  map.pm.addControls({ position:"topleft", drawMarker:true, drawPolyline:true, drawRectangle:true, drawPolygon:true, drawCircle:true, drawCircleMarker:true, editMode:true, dragMode:true, cutPolygon:true, removalMode:true });
  let selectedLayer=null, lastShapeLayer=null;
  const mType=byId('m-type'), mArea=byId('m-area'), mPerim=byId('m-perim'), mLongest=byId('m-longest');
  const isPolygonish = layer => (layer instanceof L.Polygon) || (layer instanceof L.Circle);
  function updateMetrics(layer){
    if(!layer || !isPolygonish(layer)){ mType.textContent='—'; mArea.textContent='—'; mPerim.textContent='—'; if(mLongest) mLongest.textContent='—'; return; }
    if(layer instanceof L.Circle){
      const r=layer.getRadius(); const area=Math.PI*r*r, peri=2*Math.PI*r;
      mType.textContent='Circle'; mArea.textContent=`${area.toFixed(0)} m²  (${(area/10000).toFixed(4)} ha)`; mPerim.textContent=`${peri.toFixed(2)} m`; if(mLongest) mLongest.textContent='—'; return;
    }
    const gj=layer.toGeoJSON(), type=gj.geometry?.type||'Feature'; mType.textContent=type;
    if(type==='Polygon'||type==='MultiPolygon'){
      const area=turf.area(gj); const outline=turf.polygonToLine(gj); const lengthKm=turf.length(outline,{units:'kilometers'}); const peri=lengthKm*1000;
      mArea.textContent=`${area.toFixed(0)} m²  (${(area/10000).toFixed(4)} ha)`; mPerim.textContent=`${peri.toFixed(2)} m`; if(mLongest) mLongest.textContent=`${longestEdgeMetersFromGeom(gj.geometry).toFixed(2)} m`;
    } else { mArea.textContent=mPerim.textContent='—'; if(mLongest) mLongest.textContent='—'; }
  }
  function setSelected(layer){ if(selectedLayer&&selectedLayer.setStyle&&isPolygonish(selectedLayer)) selectedLayer.setStyle(defaultStyle); selectedLayer=layer; if(selectedLayer&&selectedLayer.setStyle&&isPolygonish(selectedLayer)) selectedLayer.setStyle(activeStyle); if(isPolygonish(layer)){ lastShapeLayer=layer; updateMetrics(layer);} else updateMetrics(null); }
  function bindEditableHandlers(layer){ if(layer.setStyle && isPolygonish(layer)) layer.setStyle(defaultStyle);
    if(isPolygonish(layer)){ layer.on('click',()=>{ setSelected(layer); if(layer.pm){ if(layer.pm.enabled()) layer.pm.disable(); else layer.pm.enable({allowSelfIntersection:false,snappable:true,snapDistance:20}); } });
      layer.on('pm:edit',()=>updateMetrics(layer)); layer.on('pm:dragend',()=>updateMetrics(layer)); layer.on('pm:enable',()=>{ if(layer.setStyle) layer.setStyle(activeStyle); }); layer.on('pm:disable',()=>{ if(layer.setStyle) layer.setStyle(defaultStyle); updateMetrics(layer); }); updateMetrics(layer); } }
  map.on("pm:create", e=>{ const layer=e.layer; if(layer.setStyle&&isPolygonish(layer)) layer.setStyle(defaultStyle); if(layer.pm&&layer.pm.enable&&isPolygonish(layer)) layer.pm.enable({allowSelfIntersection:false,snappable:true,snapDistance:20}); bindEditableHandlers(layer); if(isPolygonish(layer)) setSelected(layer); });

  // Simple map click behaviours
  map.on('click', e=>{
    const t=e.originalEvent?.target;
    if(t && t.closest && t.closest('.toolbar, .metrics, .info, .leaflet-control, #sv-panel, #routebox')) return;
    if (map.pm.globalDrawModeEnabled && map.pm.globalDrawModeEnabled()) return;
    if (map.pm.globalEditEnabled && map.pm.globalEditEnabled()) return;
    if (map.pm.globalDragModeEnabled && map.pm.globalDragModeEnabled()) return;
    if(e.originalEvent?.ctrlKey){
      addViaPoint(e.latlng.lat, e.latlng.lng, 'via');
      return;
    }
    if(!e.originalEvent || !e.originalEvent.shiftKey) return;
    setPin(e.latlng.lat, e.latlng.lng, false);
  });

  // Street View
  let svService=null, panorama=null; const svPanel=byId('sv-panel'), svTitle=byId('sv-title'), svBtnClose=byId('sv-close'), svBtnPop=byId('sv-popout');
  function showSVPanel(show){ svPanel.style.display=show?'block':'none'; }
  function ensureSV(){ if(!window.google||!google.maps) return false; if(!svService) svService=new google.maps.StreetViewService(); if(!panorama) panorama=new google.maps.StreetViewPanorama(byId('pano'),{addressControl:true,linksControl:true,panControl:true,zoomControl:true,fullscreenControl:true}); return true; }
  function openSVAt(lat,lon){ if(!ensureSV()) return alert('Google Maps API not ready'); const loc={lat,lng:lon}; svService.getPanorama({location:loc,radius:70},(data,status)=>{ if(status==='OK'&&data?.location){ panorama.setPano(data.location.pano); panorama.setPov({heading:0,pitch:0}); panorama.setVisible(true); svTitle.textContent='Street View'; svBtnPop.onclick=()=>window.open(`https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${data.location.latLng.lat()},${data.location.latLng.lng()}`,'_blank','noopener'); showSVPanel(true);} else alert('No Street View here.'); }); }
  byId('btn-sv-center').addEventListener('click',()=>{ const c=map.getCenter(); openSVAt(c.lat,c.lng); });
  byId('btn-sv-pin').addEventListener('click',()=>{ const ll=pin.getLatLng(); openSVAt(ll.lat,ll.lng); });
  map.on('click', e=>{ const t=e.originalEvent?.target; if(t && t.closest && t.closest('.toolbar, .metrics, .info, .leaflet-control, #sv-panel, #routebox')) return; if(e.originalEvent?.altKey) openSVAt(e.latlng.lat,e.latlng.lng); });
  map.on('contextmenu', e=>{ if(!routeState.start) setRoutePoint('start',e.latlng.lat,e.latlng.lng,'Start'); else setRoutePoint('end',e.latlng.lat,e.latlng.lng,'End'); });

  // Routing State + UI
  const routeLayer=L.layerGroup().addTo(map);
  let startMarker=null, endMarker=null;
  const elRS=byId('route-start'), elRE=byId('route-end'), elRM=byId('route-mode'), elUseGoogle=byId('use-google');
  const rMode=byId('r-mode'), rList=byId('r-list');
  const btnPinStart=byId('btn-pin-start'), btnPinEnd=byId('btn-pin-end'), btnSwap=byId('btn-swap'), btnRoute=byId('btn-route'), btnClearRt=byId('btn-clear-route');
  const btnUseSelected=byId('btn-use-selected'), btnCopySelected=byId('btn-copy-selected'), btnZoomAll=byId('btn-zoom-all');
  const chkOdd=byId('prefer-odd'), chkAvoidHwy=byId('avoid-hwy'), chkAvoidTolls=byId('avoid-tolls'), chkAvoidFerries=byId('avoid-ferries'), selDetour=byId('detour-level');
  const viasWrap=byId('vias'), btnClearVias=byId('clear-vias');

  const routeState={ start:null, end:null, polylines:[], labels:[], meta:[], activeIdx:-1, vias:[], viaMarkers:[] };
  const PALETTE=['#e53935','#43a047','#1e88e5','#8e24aa','#fb8c00','#039be5','#6d4c41','#c0ca33','#8d6e63','#3949ab','#00897b','#f4511e'];

  function updateModeLabel(){ rMode.textContent = elRM.value || '—'; }
  updateModeLabel(); elRM.addEventListener('change', updateModeLabel);

  function renderVias(){
    viasWrap.innerHTML='';
    routeState.vias.forEach((v,i)=>{
      const chip=document.createElement('span');
      chip.className='via-chip';
      chip.innerHTML=`Via ${i+1} <button title="remove">✕</button>`;
      chip.querySelector('button').onclick=()=>removeVia(i);
      viasWrap.appendChild(chip);
    });
  }
  function addViaPoint(lat,lon, label='via'){
    routeState.vias.push({lat,lon,label});
    const m=L.circleMarker([lat,lon],{radius:6, color:'#7b1fa2', weight:2, fillOpacity:0.6}).addTo(routeLayer).bindTooltip('Via');
    routeState.viaMarkers.push(m);
    renderVias();
  }
  function removeVia(idx){
    routeState.vias.splice(idx,1);
    const m=routeState.viaMarkers.splice(idx,1)[0];
    if(m) routeLayer.removeLayer(m);
    renderVias();
  }
  btnClearVias.addEventListener('click',()=>{
    routeState.vias=[];
    routeState.viaMarkers.forEach(m=>routeLayer.removeLayer(m));
    routeState.viaMarkers=[];
    renderVias();
  });

  function setRoutePoint(which, lat, lon, label=''){
    const obj={lat,lon,label}; routeState[which]=obj; const formatted=`${lat.toFixed(6)}, ${lon.toFixed(6)}`;
    if(which==='start'){ elRS.value = label?`${label} (${formatted})`:formatted;
      if(startMarker) startMarker.setLatLng([lat,lon]); else { startMarker=L.marker([lat,lon],{draggable:true}).addTo(routeLayer).bindPopup('Start');
        startMarker.on('dragend',()=>{ const p=startMarker.getLatLng(); routeState.start={lat:p.lat,lon:p.lng,label:'Dragged Start'}; elRS.value=`${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`; }); } }
    else { elRE.value = label?`${label} (${formatted})`:formatted;
      if(endMarker) endMarker.setLatLng([lat,lon]); else { endMarker=L.marker([lat,lon],{draggable:true}).addTo(routeLayer).bindPopup('End');
        endMarker.on('dragend',()=>{ const p=endMarker.getLatLng(); routeState.end={lat:p.lat,lon:p.lng,label:'Dragged End'}; elRE.value=`${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`; }); } }
  }
  btnPinStart.addEventListener('click',()=>{ const p=pin.getLatLng(); setRoutePoint('start',p.lat,p.lng,'Pin'); });
  btnPinEnd  .addEventListener('click',()=>{ const p=pin.getLatLng(); setRoutePoint('end',p.lat,p.lng,'Pin'); });
  btnSwap    .addEventListener('click',()=>{ const a=routeState.start, b=routeState.end; routeState.start=b; routeState.end=a; const tmp=elRS.value; elRS.value=elRE.value; elRE.value=tmp; if(startMarker&&b) startMarker.setLatLng([b.lat,b.lon]); if(endMarker&&a) endMarker.setLatLng([a.lat,a.lon]); });

  function clearRoutes(){ routeState.polylines.forEach(pl=>routeLayer.removeLayer(pl)); routeState.labels.forEach(lb=>routeLayer.removeLayer(lb)); routeState.polylines=[]; routeState.labels=[]; routeState.meta=[]; routeState.activeIdx=-1; rList.innerHTML=''; }
  btnClearRt.addEventListener('click', clearRoutes);

  async function resolvePoint(text){
    const raw=(text||'').trim(); if(!raw) return null;
    const parts=raw.replace(/[()]/g,'').split(/[,\s]+/).filter(Boolean);
    if(parts.length===2 && !isNaN(+parts[0]) && !isNaN(+parts[1])){
      const a=+parts[0], b=+parts[1];
      if(Math.abs(a)>1000 && Math.abs(b)>1000){ const [lon,lat]=proj4(OSGB,WGS84,[a,b]); return {lat,lon,label:'E/N'}; }
      if(Math.abs(a)<=90 && Math.abs(b)<=180){ return {lat:a,lon:b,label:'Lat/Lon'}; }
    }
    const maybePC=normalizeUKPostcode(raw);
    if(maybePC){ try{ const r=await fetch(`https://api.postcodes.io/postcodes/${maybePC}`); const j=await r.json(); if(j?.status===200&&j.result) return {lat:j.result.latitude, lon:j.result.longitude, label:j.result.postcode}; }catch{} }
    try{
      const url=`https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(raw)}&countrycodes=gb&limit=1&accept-language=en-GB`;
      const r=await fetch(url,{headers:{'Accept':'application/json'}}); const j=await r.json();
      if(j&&j.length) return {lat:+j[0].lat, lon:+j[0].lon, label:(j[0].display_name||'').split(',')[0]||'Address'};
    }catch{}
    return null;
  }

  function midpointLatLng(latlngs){ return latlngs[Math.floor(latlngs.length/2)]; }
  function makeNumberBadge(n,color,at){ const icon=L.divIcon({ className:'route-badge', html:`<div style="background:${color};color:#fff;border-radius:50%;width:22px;height:22px;display:flex;align-items:center;justify-content:center;font:12px/22px system-ui;box-shadow:0 1px 4px rgba(0,0,0,.25);">${n}</div>`, iconSize:[22,22], iconAnchor:[11,11] }); return L.marker(at,{icon}); }

  function setActiveRoute(idx){
    routeState.activeIdx=idx;
    routeState.polylines.forEach((pl,i)=>{
      pl.setStyle({weight: i===idx?6:4, opacity: i===idx?0.95:0.6, dashArray: i===idx?null:'6,6'});
      if (i===idx && pl.bringToFront) pl.bringToFront();
    });
    const items = Array.from(rList.querySelectorAll('.route-item'));
    items.forEach((el,i)=> el.classList.toggle('active', i===idx));
    if(idx>=0 && routeState.polylines[idx]) map.fitBounds(routeState.polylines[idx].getBounds(), {padding:[30,30]});
  }

  function hashCoords(coords){
    const rounded = coords.map(ll=>[+ll[0].toFixed(5), +ll[1].toFixed(5)]);
    return JSON.stringify([rounded.length, rounded.slice(0,200)]);
  }

  function detourOffsets(level){
    if(level==='none') return [];
    if(level==='light') return [150, -150];
    if(level==='medium') return [200, -200, 450, -450];
    return [250, -250, 600, -600, 1000, -1000]; // heavy
  }

  function buildDetourVias(start, end, level){
    const mids = [];
    try{
      const startPt = turf.point([start.lon, start.lat]);
      const endPt = turf.point([end.lon, end.lat]);
      const mid = turf.midpoint(startPt, endPt);
      const bearing = turf.bearing(startPt, endPt);
      const perp1 = bearing + 90;
      const offs = detourOffsets(level);
      offs.forEach(m => {
        const via = turf.destination(mid, Math.abs(m)/1000, m>0?perp1:perp1-180, {units:'kilometers'});
        const [lon, lat] = via.geometry.coordinates;
        mids.push({lat, lon, label: m>0?`via-R${Math.abs(m)}`:`via-L${Math.abs(m)}`});
      });
    }catch{}
    return mids;
  }

  btnZoomAll.addEventListener('click',()=>{
    const groups = routeState.polylines.filter(Boolean);
    if(!groups.length) return;
    let bounds = groups[0].getBounds();
    groups.slice(1).forEach(pl => bounds = bounds.extend(pl.getBounds()));
    map.fitBounds(bounds, {padding:[30,30]});
  });

  async function planRoutes(){
    try{
      if(!routeState.start){ const s=await resolvePoint(elRS.value); if(!s) return alert('Set a valid Start.'); setRoutePoint('start',s.lat,s.lon,s.label); }
      if(!routeState.end){ const e=await resolvePoint(elRE.value); if(!e) return alert('Set a valid End.'); setRoutePoint('end',e.lat,e.lon,e.label); }
      const {start,end}=routeState; if(!start||!end) return;
      clearRoutes(); rMode.textContent = elRM.value || '—';

      const profile = elRM.value;
      const palette = PALETTE.slice();
      const overallSeen = new Set();
      let displayOrder = 0;

      // Assemble vias: user‑added + synthetic detours if "Explore off‑beat" or detour level set
      let synthetic = [];
      if (chkOdd.checked || selDetour.value!=='none'){
        synthetic = buildDetourVias(start, end, selDetour.value);
      }
      const allViaSets = [];
      // Each set is a list of vias to apply in order (Google uses waypoints; OSRM appends coord sequence)
      if (routeState.vias.length) allViaSets.push(routeState.vias);
      synthetic.forEach(v => allViaSets.push([v])); // single‑via pushes

      // Always include the "no via" baseline set first
      allViaSets.unshift([]);

      // ---- OSRM ----
      async function fetchOSRM(profile, start, end, vias, avoidFerries){
        const coords = [[start.lon,start.lat], ...vias.map(v=>[v.lon,v.lat]), [end.lon,end.lat]]
          .map(pair=>pair.join(',')).join(';');
        const params = new URLSearchParams({ overview:'full', geometries:'geojson', alternatives:'true', steps:'false' });
        if (avoidFerries) params.set('exclude','ferry'); // supported on demo server
        const url = `https://router.project-osrm.org/route/v1/${profile}/${coords}?${params}`;
        const j = await fetch(url).then(r=>r.json()).catch(()=>null);
        if (!j||!j.routes) return [];
        return j.routes.map(rt=>({ provider:'OSRM', tag: vias.length?vias.map(v=>v.label).join('+')||'via':'base', distance:rt.distance, duration:rt.duration, coords: rt.geometry.coordinates.map(([lon,lat])=>[lat,lon]) }));
      }

      // ---- Google ----
      async function fetchGoogle(profile, start, end, vias, avoids){
        if (!window.google?.maps) return [];
        const svc = new google.maps.DirectionsService();
        const gMode = profile==='driving'?'DRIVING':profile==='walking'?'WALKING':'BICYCLING';
        const req = {
          origin: {lat:start.lat, lng:start.lon},
          destination: {lat:end.lat, lng:end.lon},
          travelMode: gMode,
          provideRouteAlternatives: true
        };
        if (vias && vias.length){
          req.waypoints = vias.map(v=>({ location:{lat:v.lat, lng:v.lon}, stopover:false }));
        }
        if (avoids.length) req.avoid = avoids;
        const res = await new Promise(resolve => svc.route(req,(r,st)=>resolve(st==='OK'?r:null)));
        if (!res?.routes) return [];
        return res.routes.map(r=>{
          const path = (r.overview_path||[]).map(ll=>[ll.lat(), ll.lng()]);
          const legs = r.legs && r.legs[0];
          const distance = legs?.distance?.value || 0;
          const duration = legs?.duration?.value || 0;
          return { provider:'Google', tag: vias.length?vias.map(v=>v.label).join('+')||'via':'base', distance, duration, coords: path };
        });
      }

      // Collect across via sets and avoids
      for (const vias of allViaSets){
        // OSRM
        const osrmRoutes = await fetchOSRM(profile, start, end, vias, chkAvoidFerries.checked);
        osrmRoutes.forEach(rt=>{
          const h=hashCoords(rt.coords); if (overallSeen.has(h)) return; overallSeen.add(h);
          const idx=routeState.polylines.length; const color=palette[idx % palette.length];
          const poly=L.polyline(rt.coords,{color,weight:4,opacity:0.7}).addTo(routeLayer);
          routeState.polylines.push(poly);
          const mid=midpointLatLng(rt.coords); const badge=makeNumberBadge(++displayOrder,color,mid).addTo(routeLayer);
          routeState.labels.push(badge); routeState.meta.push({provider:`OSRM (${rt.tag||'base'})`, distance:rt.distance, duration:rt.duration, color});
          const km=(rt.distance/1000).toFixed(2); const mins=Math.round(rt.duration/60); const hrs=Math.floor(mins/60), rem=mins%60; const durTxt=hrs?`${hrs}h ${rem}m`:`${mins} min`;
          const item=document.createElement('div'); item.className='route-item';
          item.innerHTML=`<div class="route-swatch" style="background:${color}"></div>
            <div><b>${displayOrder}.</b> ${km} km • ${durTxt} <span class="provider-tag">OSRM</span> ${rt.tag&&rt.tag!=='base'?`<span class="provider-tag">${rt.tag}</span>`:''}</div>`;
          item.onclick=()=>setActiveRoute(idx); poly.on('click',()=>setActiveRoute(idx)); rList.appendChild(item);
        });

        // Google
        if (elUseGoogle.checked){
          const avoids=[];
          if (chkAvoidHwy.checked) avoids.push('HIGHWAYS');
          if (chkAvoidTolls.checked) avoids.push('TOLLS');
          if (chkAvoidFerries.checked) avoids.push('FERRIES');
          const gRoutes = await fetchGoogle(profile, start, end, vias, avoids);
          gRoutes.forEach(rt=>{
            const h=hashCoords(rt.coords); if (overallSeen.has(h)) return; overallSeen.add(h);
            const idx=routeState.polylines.length; const color=palette[idx % palette.length];
            const poly=L.polyline(rt.coords,{color,weight:4,opacity:0.7}).addTo(routeLayer);
            routeState.polylines.push(poly);
            const mid=midpointLatLng(rt.coords); const badge=makeNumberBadge(++displayOrder,color,mid).addTo(routeLayer);
            routeState.labels.push(badge); routeState.meta.push({provider:`Google (${rt.tag||'base'})`, distance:rt.distance, duration:rt.duration, color});
            const km=(rt.distance/1000).toFixed(2); const mins=Math.round(rt.duration/60); const hrs=Math.floor(mins/60), rem=mins%60; const durTxt=hrs?`${hrs}h ${rem}m`:`${mins} min`;
            const item=document.createElement('div'); item.className='route-item';
            item.innerHTML=`<div class="route-swatch" style="background:${color}"></div>
              <div><b>${displayOrder}.</b> ${km} km • ${durTxt} <span class="provider-tag">Google</span> ${rt.tag&&rt.tag!=='base'?`<span class="provider-tag">${rt.tag}</span>`:''} ${avoids.length?`<span class="provider-tag">avoid:${avoids.join(',').toLowerCase()}</span>`:''}</div>`;
            item.onclick=()=>setActiveRoute(idx); poly.on('click',()=>setActiveRoute(idx)); rList.appendChild(item);
          });
        }
      }

      if(routeState.polylines.length===0) alert('No routes found. Try adding a via (Ctrl+Click) or increasing Detour.');
      else setActiveRoute(0);
    }catch(err){
      console.error(err); alert('Routing failed. Check points and try again.');
    }
  }

  btnRoute.addEventListener('click', planRoutes);

  // Use / Copy selected route
  function getActiveRouteCoords(){ const idx=routeState.activeIdx; if(idx==null||idx<0) return null; const pl=routeState.polylines[idx]; if(!pl) return null; const latlngs=pl.getLatLngs(); return Array.isArray(latlngs[0])?latlngs.flat():latlngs; }
  byId('btn-use-selected').addEventListener('click',()=>{ const pts=getActiveRouteCoords(); if(!pts||!pts.length) return alert('Select a route first.'); const poly=L.polyline(pts,{color:'#007ACC',weight:3,opacity:0.95}).addTo(map); if(poly.pm&&poly.pm.enable) poly.pm.enable({snappable:true,snapDistance:20}); });
  byId('btn-copy-selected').addEventListener('click', async ()=>{ const pts=getActiveRouteCoords(); if(!pts||!pts.length) return alert('Select a route first.'); const coords=pts.map(ll=>[ll.lng,ll.lat]); const text=JSON.stringify(coords); if(navigator.clipboard?.writeText) await navigator.clipboard.writeText(text); else { const ta=document.createElement('textarea'); ta.value=text; ta.style.position='fixed'; ta.style.top='-9999px'; document.body.appendChild(ta); ta.focus(); ta.select(); document.execCommand('copy'); ta.remove(); } });

  // Init
  (async()=>{ await updateInfo(centre[0], centre[1]); })();
</script>

<noscript>Enable JavaScript to view the map.</noscript>
</body>
</html>
