<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <title>Leaflet + Google + Unified UK Search + Draw + Edit + Metrics</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Fullscreen -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.css">
  <script src="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.js"></script>

  <!-- Leaflet.Geoman (drawing/editing) -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css">
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js"></script>

  <!-- GoogleMutant (Leaflet grid layer for Google) -->
  <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.15.0/dist/Leaflet.GoogleMutant.js"></script>

  <!-- Proj4 for OSGB36 <-> WGS84 transforms -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>

  <!-- Turf.js for area/perimeter -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100vh; position: relative; }

    /* One-line toolbar: no-wrap, full width, horizontal scroll on overflow */
    .toolbar {
      position: absolute; z-index: 1000; top: 10px; left: 60px; right: 10px;
      background: #fff; border-radius: 12px; padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,.18); font: 14px system-ui, sans-serif;

      display: flex; align-items: center; gap: 8px;
      flex-wrap: nowrap; white-space: nowrap;
      overflow-x: auto; overflow-y: hidden;
      -webkit-overflow-scrolling: touch; scrollbar-width: thin;
    }
    .toolbar select, .toolbar input, .toolbar button {
      padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px;
      flex: 0 0 auto;
    }
    #q { min-width: 320px; flex: 1 1 420px; }
    .toolbar .spacer { width: 6px; flex: 0 0 auto; }

    /* Info panel (pin details) */
    .info {
      position: absolute; z-index: 1000; right: 10px; bottom: 50px;
      background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif;
      min-width: 280px; max-width: 360px;
    }
    .info h4 { margin: 0 0 6px 0; font-size: 14px; }
    .info .row { margin: 4px 0; }
    .info code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }

    /* Polygon metrics panel */
    .metrics {
      position: absolute; z-index: 1000; left: 10px; bottom: 50px;
      background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif;
      min-width: 260px; max-width: 380px;
    }
    .metrics h4 { margin: 0 0 6px 0; font-size: 14px; }
    .metrics .row { margin: 4px 0; }
    .metrics code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }
    .metrics .btn {
      padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; background: #f7f7f7; cursor: pointer;
    }
    .metrics .btn + .btn { margin-left: 6px; }

    @media (max-width: 640px) {
      #q { min-width: 260px; flex-basis: 300px; }
    }

    /* Lower the base layers control */
    .leaflet-top.leaflet-right .leaflet-control-layers { margin-top: 75px !important; }

    /* Defensive: in case any geocoder control sneaks in */
    .leaflet-control-geocoder { display: none !important; }
  </style>
</head>
<body>
<div id="map">
  <!-- Unified Search + Drawing toolbar (single line) -->
  <div class="toolbar" id="ui-toolbar">
    <select id="mode" title="Search mode">
      <option value="postcode">Postcode / Address</option>
      <option value="latlon">Lat, Lon</option>
      <option value="en">Easting, Northing</option>
    </select>

    <input id="q" type="text"
           placeholder="SY3 0NS  |  52.677027, -2.773167  |  349000, 306000" />

    <button id="go">Search</button>

    <span class="spacer"></span>

    <button id="btn-export" title="Download drawings as GeoJSON">Export</button>
    <button id="btn-import" title="Load drawings from GeoJSON">Import</button>
    <input id="file-import" type="file" accept=".json,.geojson" style="display:none">

    <span class="spacer"></span>

    <button id="btn-edit-all" title="Enable edit mode for all shapes">Edit All</button>
    <button id="btn-drag"     title="Enable drag mode for shapes">Drag Mode</button>
    <button id="btn-finish"   title="Disable edit/drag modes">Finish Edit</button>
  </div>

  <!-- Pin info panel -->
  <div class="info" id="info">
    <h4>DROPPED PIN INFORMATION:</h4>
    <div class="row" id="addr">Address: <em>—</em></div>
    <div class="row">Lat/Lon: <code id="latlon">—</code></div>
    <div class="row">Easting/Northing: <code id="en">—</code></div>
    <div class="row" style="opacity:.8">Tip: Click a polygon to edit its vertices. Shift+click adds a vertex, right-click removes (while in edit mode).</div>
  </div>

  <!-- Polygon metrics panel -->
  <div class="metrics" id="metrics">
    <h4>DRAWN POLYGON INFORMATION:</h4>
    <div class="row">Type: <code id="m-type">—</code></div>
    <div class="row">Area: <code id="m-area">—</code></div>
    <div class="row">Perimeter: <code id="m-perim">—</code></div>
    <div class="row">Longest edge: <code id="m-longest">—</code></div>
    <div class="row" style="margin-top:8px;">
      <button id="btn-copy" class="btn">Copy Coords</button>
      <button id="btn-center-shape" class="btn">Center on Shape</button>
    </div>
  </div>
</div>

<!-- Google Maps JS (async, no callback) -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAdHcFCZWzjEOj98oEn5AfufQMR0p9VgLA&v=weekly&loading=async"></script>

<script type="module">
  // ---------- Config ----------
  const centre = [52.677027, -2.773167]; // 29 Green Lane, SY3 0NS
  proj4.defs('EPSG:27700', '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs');
  const WGS84 = 'EPSG:4326';
  const OSGB  = 'EPSG:27700';
  
  const mLongest = document.getElementById('m-longest');

  const byId = id => document.getElementById(id);
  const isNum = v => typeof v === 'number' && isFinite(v) && !isNaN(v);

  // ---------- Basemaps ----------
  const esriImagery = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 20, attribution: "Imagery © Esri" }
  );
  const esriLabels = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 20, attribution: "Labels © Esri" }
  );
  const osmStreets = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    { maxZoom: 20, attribution: "© OpenStreetMap contributors" }
  );

  // Map init with fallback
  const map = L.map("map", {
    center: centre,
    zoom: 19,
    layers: [esriImagery, esriLabels],
    fullscreenControl: true
  });

  // Prevent clicks on UI/controls from triggering map click handlers
  function blockEventsFor(selector) {
    document.querySelectorAll(selector).forEach(el => {
      L.DomEvent.disableClickPropagation(el);
      L.DomEvent.disableScrollPropagation(el);
    });
  }
  blockEventsFor('#ui-toolbar, #metrics, #info');
  blockEventsFor('.leaflet-control-container');

  // Initial pin
  let pin = L.marker(centre).addTo(map).bindPopup("29 Green Lane, SY3 0NS").openPopup();

  // Pin info panel
  const elAddr = byId('addr');
  const elLatLon = byId('latlon');
  const elEN = byId('en');

  // UK postcode normaliser/checker
  function normalizeUKPostcode(str) {
    if (!str) return null;
    const s = str.toUpperCase().replace(/\s+/g, '');
    // Basic shape check; we’ll let the API validate fully
    return /^[A-Z]{1,2}\d[A-Z\d]?\d[A-Z]{2}$/.test(s) ? s : null;
  }
  
  async function updateInfo(lat, lon, labelHint = '') {
    const latStr = lat.toFixed(6), lonStr = lon.toFixed(6);
    elLatLon.textContent = `${latStr}, ${lonStr}`;
  
    const [E, N] = proj4(WGS84, OSGB, [lon, lat]);
    elEN.textContent = `${Math.round(E)}, ${Math.round(N)}`;
  
    let addr = labelHint || 'Unknown location';
    try {
      const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latStr}&lon=${lonStr}&addressdetails=1&zoom=18&accept-language=en-GB`;
      const resp = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const data = await resp.json();
      addr = data?.display_name || addr;
    } catch {}
  
    // Authoritative postcode near this lat/lon
    try {
      const pr = await fetch(`https://api.postcodes.io/postcodes?lon=${lonStr}&lat=${latStr}&limit=1`);
      const pj = await pr.json();
      const pc = pj?.result?.[0]?.postcode;
      if (pc) {
        // Prefer showing the official postcode clearly
        elAddr.innerHTML = `Address: <em>${addr}</em><br/>Postcode: <code>${pc}</code>`;
        pin.setPopupContent(`${addr} (${pc})`);
        return;
      }
    } catch {}
  
    // Fallback if no postcode found
    elAddr.innerHTML = `Address: <em>${addr}</em>`;
    pin.setPopupContent(addr);
  }

  function setPin(lat, lon, labelHint = '', recenter = false) {
    if (!isNum(lat) || !isNum(lon)) return;
    pin.setLatLng([lat, lon]);
    pin.addTo(map).openPopup();
    if (recenter) {
      map.setView([lat, lon], Math.max(map.getZoom(), 18));
    }
    updateInfo(lat, lon, labelHint);
  }


  // Guard: ignore clicks that originate from UI/controls
  function clickCameFromUI(evt) {
    const t = evt.originalEvent?.target;
    return !!(t && t.closest && t.closest('.toolbar, .metrics, .info, .leaflet-control'));
  }

  // ---------- Google base (async ready) ----------
  async function ensureGoogle() {
    for (let i = 0; i < 400; i++) {
      if (window.google?.maps?.importLibrary) break;
      await new Promise(r => setTimeout(r, 25));
    }
    if (!window.google?.maps?.importLibrary) throw new Error('Google Maps JS API not ready');
    await google.maps.importLibrary("maps");
  }

  try {
    await ensureGoogle();
    const gRoad   = L.gridLayer.googleMutant({ type: "roadmap",   maxZoom: 21 });
    const gHybrid = L.gridLayer.googleMutant({ type: "hybrid",    maxZoom: 21 });
    const gSat    = L.gridLayer.googleMutant({ type: "satellite", maxZoom: 21 });

    map.addLayer(gHybrid); // default to Hybrid

    const baseMaps = {
      "Google Roadmap": gRoad,
      "Google Hybrid":  gHybrid,
      "Google Satellite": gSat,
      "Esri Satellite (fallback)": esriImagery,
      "OSM Streets (fallback)": osmStreets
    };
    const overlays = { "Esri Labels (for Esri Hybrid)": esriLabels };
    L.control.layers(baseMaps, overlays, { collapsed: false }).addTo(map);

  } catch (e) {
    console.warn('Google base unavailable, staying on Esri/OSM.', e);
    L.control.layers(
      { "Esri Satellite": esriImagery, "OSM Streets": osmStreets },
      { "Esri Labels (Hybrid)": esriLabels },
      { collapsed: false }
    ).addTo(map);
  }

  // ---------- Unified Search ----------
  byId('mode').addEventListener('change', () => {
    const m = byId('mode').value;
    byId('q').placeholder =
      m === 'postcode' ? 'SY3 0NS  |  10 Downing Street' :
      m === 'latlon'   ? '52.677027, -2.773167' :
                         '349000, 306000';
  });

  byId('go').addEventListener('click', runUnifiedSearch);
  byId('q').addEventListener('keydown', e => { if (e.key === 'Enter') runUnifiedSearch(); });

  async function runUnifiedSearch() {
    const mode = byId('mode').value;
    const raw  = byId('q').value.trim();
    if (!raw) return;

    if (mode === 'latlon') {
      const parts = raw.split(/[,\s]+/).filter(Boolean);
      if (parts.length !== 2) return alert('Use: 52.677027, -2.773167');
      const lat = parseFloat(parts[0]), lon = parseFloat(parts[1]);
      if (!isNum(lat) || !isNum(lon)) return alert('Invalid lat/lon.');
      setPin(lat, lon, 'Lat/Lon', true); return;
    }

    if (mode === 'en') {
      const parts = raw.split(/[,\s]+/).filter(Boolean);
      if (parts.length !== 2) return alert('Use: 349000, 306000 (E,N)');
      const E = parseFloat(parts[0]), N = parseFloat(parts[1]);
      if (!isNum(E) || !isNum(N)) return alert('Invalid Easting/Northing.');
      const [lon, lat] = proj4(OSGB, WGS84, [E, N]);
      setPin(lat, lon, `OSGB36: ${Math.round(E)}, ${Math.round(N)}`, /*recenter*/ true);return;
    }

    // Postcode / Address mode
    // If it *looks* like a UK postcode, use postcodes.io (authoritative).
    // Otherwise, fall back to Nominatim full-text search.
    try {
      const norm = normalizeUKPostcode(raw);
      if (norm) {
        const resp = await fetch(`https://api.postcodes.io/postcodes/${norm}`);
        const j = await resp.json();
        if (j && j.status === 200 && j.result) {
          const { latitude: lat, longitude: lon, postcode } = j.result;
          setPin(lat, lon, postcode, /*recenter*/ true);
          return;
        } else {
          alert('Postcode not found in postcodes.io; falling back to address search.');
          // fall through to Nominatim
        }
      }
    
      // Nominatim address search (fallback or non-postcode text)
      const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(raw)}&countrycodes=gb&limit=1&addressdetails=1&accept-language=en-GB`;
      const r = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const j = await r.json();
      if (j && j.length) {
        const { lat, lon, display_name, boundingbox } = j[0];
        setPin(parseFloat(lat), parseFloat(lon), display_name, true);
        if (boundingbox) {
          const bb = [[+boundingbox[0], +boundingbox[2]],[+boundingbox[1], +boundingbox[3]]];
          map.fitBounds(bb, { maxZoom: 19 });
        }
      } else alert('No results.');
    } catch { alert('Search failed (network or rate limit).'); }
  }

  // ---------- Geoman drawing & EDITING + Metrics ----------
  const defaultStyle = { color: "#00AEEF", weight: 2, fillOpacity: 0.18 };
  const activeStyle  = { color: "#007ACC", weight: 2, fillOpacity: 0.20 };

  map.pm.setGlobalOptions({
    snappable: true,
    snapDistance: 20,
    allowSelfIntersection: false,
    continueDrawing: false
  });

  map.pm.addControls({
    position: "topleft",
    drawMarker: true,
    drawPolyline: true,
    drawRectangle: true,
    drawPolygon: true,
    drawCircle: true,
    drawCircleMarker: true,
    editMode: true,
    dragMode: true,
    cutPolygon: true,
    removalMode: true
  });

  // --- Keep map still while drawing ---
  let isDrawing = false;
  map.on('pm:drawstart', () => { isDrawing = true; map.doubleClickZoom.disable(); });
  map.on('pm:drawend',   () => { isDrawing = false; map.doubleClickZoom.enable(); });
  map.on('pm:create',    () => { isDrawing = false; map.doubleClickZoom.enable(); });

  // Pin-placement (suppressed while drawing/editing/dragging or when clicking UI)
  map.on('click', e => {
    if (clickCameFromUI(e)) return;
    if (isDrawing) return;
    if (map.pm.globalDrawModeEnabled && map.pm.globalDrawModeEnabled()) return;
    if (map.pm.globalEditEnabled && map.pm.globalEditEnabled()) return;
    if (map.pm.globalDragModeEnabled && map.pm.globalDragModeEnabled()) return;
  
    // Only allow pin drop on Shift+Click, and do NOT recenter the map
    if (!e.originalEvent || !e.originalEvent.shiftKey) return;
    setPin(e.latlng.lat, e.latlng.lng, 'Dropped pin', /*recenter*/ false);
  });

  // Track the "current" shape for metrics/copy/centering
  let selectedLayer = null;  // last thing clicked (if shape)
  let lastShapeLayer = null; // last POLYGON/CIRCLE

  const mType  = byId('m-type');
  const mArea  = byId('m-area');
  const mPerim = byId('m-perim');

  function isPolygonish(layer) {
    return (layer instanceof L.Polygon) || (layer instanceof L.Circle);
  }

  function updateMetrics(layer) {
    if (!layer || !isPolygonish(layer)) {
      mType.textContent='—'; mArea.textContent='—'; mPerim.textContent='—';
      if (mLongest) mLongest.textContent = '—';
      return;
    }

    if (layer instanceof L.Circle) {
      const r = layer.getRadius();
      const area = Math.PI * r * r;
      const peri = 2 * Math.PI * r;
      mType.textContent = 'Circle';
      mArea.textContent = `${area.toFixed(0)} m²  (${(area/10000).toFixed(4)} ha)`;
      mPerim.textContent = `${peri.toFixed(2)} m`;
      if (mLongest) mLongest.textContent = '—'; // <-- add this
      return;
    }
    try {
      const gj = layer.toGeoJSON();
      const type = gj.geometry?.type || 'Feature';
      mType.textContent = type;
      if (type === 'Polygon' || type === 'MultiPolygon') {
        const area = turf.area(gj);
        const outline = turf.polygonToLine(gj);
        const lengthKm = turf.length(outline, { units: 'kilometers' });
        const peri = lengthKm * 1000;
        mArea.textContent = `${area.toFixed(0)} m²  (${(area/10000).toFixed(4)} ha)`;
        mPerim.textContent = `${peri.toFixed(2)} m`;
      
        // NEW: Longest edge
        if (mLongest) {
          const longest = longestEdgeMetersFromGeom(gj.geometry);
          mLongest.textContent = `${longest.toFixed(2)} m`;
        }
      } else {
        mArea.textContent = `—`; mPerim.textContent = `—`;
        if (mLongest) mLongest.textContent = '—';
      }
    } catch {
      mType.textContent='—'; mArea.textContent='—'; mPerim.textContent='—';
    }
  }

  function setSelected(layer) {
    if (selectedLayer && selectedLayer.setStyle && isPolygonish(selectedLayer)) {
      selectedLayer.setStyle(defaultStyle);
    }
    selectedLayer = layer;
    if (selectedLayer && selectedLayer.setStyle && isPolygonish(selectedLayer)) {
      selectedLayer.setStyle(activeStyle);
    }
    if (isPolygonish(layer)) {
      lastShapeLayer = layer;
      updateMetrics(layer);
    } else {
      updateMetrics(null);
    }
  }

  function bindEditableHandlers(layer, isImported = false) {
    if (layer.setStyle && !isImported && isPolygonish(layer)) layer.setStyle(defaultStyle);

    if (isPolygonish(layer)) {
      layer.on('click', () => {
        setSelected(layer);
        if (layer.pm) {
          if (layer.pm.enabled()) layer.pm.disable();
          else layer.pm.enable({ allowSelfIntersection: false, snappable: true, snapDistance: 20 });
        }
      });

      layer.on('pm:edit',   () => updateMetrics(layer));
      layer.on('pm:dragend',() => updateMetrics(layer));
      layer.on('pm:enable', () => { if (layer.setStyle) layer.setStyle(activeStyle); });
      layer.on('pm:disable',() => { if (layer.setStyle) layer.setStyle(defaultStyle); updateMetrics(layer); });

      updateMetrics(layer);
    }
  }

  map.on("pm:create", e => {
    const layer = e.layer;
    if (layer.setStyle && isPolygonish(layer)) layer.setStyle(defaultStyle);
    if (layer.pm && layer.pm.enable && isPolygonish(layer)) {
      layer.pm.enable({ allowSelfIntersection: false, snappable: true, snapDistance: 20 });
    }
    bindEditableHandlers(layer);
    if (isPolygonish(layer)) setSelected(layer); // make it current
    console.log("Created feature:", layer.toGeoJSON());
  });

  map.eachLayer(l => { if (l.pm) bindEditableHandlers(l); });

  byId('btn-edit-all').onclick = () => { map.pm.toggleGlobalEditMode(); };
  byId('btn-drag').onclick     = () => { map.pm.toggleGlobalDragMode(); };
  byId('btn-finish').onclick   = () => {
    if (map.pm.globalEditEnabled()) map.pm.toggleGlobalEditMode();
    if (map.pm.globalDragModeEnabled && map.pm.globalDragModeEnabled()) map.pm.toggleGlobalDragMode();
    map.eachLayer(l => { if (l.pm && l.pm.enabled && l.pm.enabled()) l.pm.disable(); });
    if (lastShapeLayer) updateMetrics(lastShapeLayer);
  };

  // ---------- Copy coords & Center buttons ----------
  const btnCopy = byId('btn-copy');
  const btnCenterShape = byId('btn-center-shape');

  btnCopy.addEventListener('click', async () => {
    if (!lastShapeLayer) { alert('Draw or select a polygon/circle first.'); return; }
    try {
      const text = buildCoordsText(lastShapeLayer);
      await copyText(text);
      flashBtn(btnCopy, 'Copied!');
    } catch (err) {
      console.error(err);
      alert('Failed to copy.');
    }
  });

  btnCenterShape.addEventListener('click', () => {
    if (lastShapeLayer && isPolygonish(lastShapeLayer)) {
      if (lastShapeLayer instanceof L.Circle) {
        const c = lastShapeLayer.getLatLng();
        map.flyTo(c, Math.max(map.getZoom(), 18));
      } else {
        const b = lastShapeLayer.getBounds();
        map.fitBounds(b, { maxZoom: Math.max(map.getZoom(), 19) });
      }
    } else if (pin) {
      map.flyTo(pin.getLatLng(), Math.max(map.getZoom(), 18));
    }
  });

  // Build coordinates payload from shape (GeoJSON geometry.coordinates)
  function buildCoordsText(layer) {
    if (layer instanceof L.Circle) {
      const c = layer.getLatLng();
      const rMeters = layer.getRadius();
      const poly = turf.circle([c.lng, c.lat], rMeters / 1000, { steps: 64, units: 'kilometers' });
      return JSON.stringify(poly.geometry.coordinates);
    }
    const gj = layer.toGeoJSON();
    const geom = gj && gj.geometry ? gj.geometry : null;
    if (!geom) throw new Error('No geometry found.');
    if (!(geom.type === 'Polygon' || geom.type === 'MultiPolygon')) {
      throw new Error('Only polygons/circles are exported here.');
    }
    return JSON.stringify(geom.coordinates);
  }

  // Clipboard helpers
  async function copyText(text) {
    if (navigator.clipboard?.writeText) return navigator.clipboard.writeText(text);
    const ta = document.createElement('textarea');
    ta.value = text; ta.style.position = 'fixed'; ta.style.top = '-9999px';
    document.body.appendChild(ta); ta.focus(); ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
  }

  function flashBtn(btn, msg) {
    const orig = btn.textContent;
    btn.textContent = msg; btn.disabled = true;
    setTimeout(() => { btn.textContent = orig; btn.disabled = false; }, 1200);
  }

  // Return longest edge length (metres) from a Polygon/MultiPolygon GeoJSON geometry
  function longestEdgeMetersFromGeom(geom) {
    let longest = 0;
  
    const processRing = (ring) => {
      // ring: array of [lon, lat]
      const n = ring.length;
      if (n < 2) return;
      for (let i = 0; i < n; i++) {
        const a = ring[i];
        const b = ring[(i + 1) % n]; // close ring
        const km = turf.distance(a, b, { units: 'kilometers' });
        const m = km * 1000;
        if (m > longest) longest = m;
      }
    };
  
    if (geom.type === 'Polygon') {
      // coords: [ [ring1...], [hole1...], ... ]
      geom.coordinates.forEach(processRing);
    } else if (geom.type === 'MultiPolygon') {
      // coords: [ [ [ring1...], [hole1...] ], ... ]
      geom.coordinates.forEach(poly => poly.forEach(processRing));
    }
    return longest;
  }

  // Initial pin info
  (async () => { await updateInfo(centre[0], centre[1], '29 Green Lane, SY3 0NS'); })();
</script>

<noscript>Enable JavaScript to view the map.</noscript>
</body>
</html>
