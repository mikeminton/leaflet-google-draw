<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <title>Leaflet + Google + Unified UK Search + Draw + Edit + Metrics + Street View + Routing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Fullscreen -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.css">
  <script src="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.js"></script>

  <!-- Leaflet.Geoman (drawing/editing) -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css">
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js"></script>

  <!-- GoogleMutant (Leaflet grid layer for Google) -->
  <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.15.0/dist/Leaflet.GoogleMutant.js"></script>

  <!-- Proj4 for OSGB36 <-> WGS84 transforms -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>

  <!-- Turf.js for area/perimeter -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100vh; position: relative; }

    /* One-line toolbar */
    .toolbar {
      position: absolute; z-index: 1000; top: 10px; left: 60px; right: 10px;
      background: #fff; border-radius: 12px; padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,.18); font: 14px system-ui, sans-serif;
      display: flex; align-items: center; gap: 8px;
      flex-wrap: nowrap; white-space: nowrap;
      overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; scrollbar-width: thin;
    }
    .toolbar select, .toolbar input, .toolbar button {
      padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; flex: 0 0 auto; cursor: pointer;
    }
    #q { min-width: 320px; flex: 1 1 420px; }
    .toolbar .spacer { width: 6px; flex: 0 0 auto; }

    /* Small inputs for routing */
    .mini { width: 220px; }

    /* Pin info panel */
    .info {
      position: absolute; z-index: 1000; right: 10px; bottom: 50px;
      background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif;
      min-width: 280px; max-width: 360px;
    }
    .info h4 { margin: 0 0 6px 0; font-size: 14px; }
    .info .row { margin: 4px 0; }
    .info code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }

    /* Polygon metrics panel */
    .metrics {
      position: absolute; z-index: 1000; left: 10px; bottom: 50px;
      background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif;
      min-width: 260px; max-width: 380px;
    }
    .metrics h4 { margin: 0 0 6px 0; font-size: 14px; }
    .metrics .row { margin: 4px 0; }
    .metrics code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }
    .metrics .btn {
      padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; background: #f7f7f7; cursor: pointer;
    }
    .metrics .btn + .btn { margin-left: 6px; }

    /* Route summary box */
    .routebox {
      position: absolute; z-index: 1000; left: 10px; top: 64px;
      background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif;
      min-width: 240px; max-width: 360px;
    }
    .routebox h4 { margin: 0 0 6px 0; font-size: 14px; }
    .routebox .row { margin: 4px 0; }
    .routebox code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }

    @media (max-width: 640px) { #q { min-width: 260px; flex-basis: 300px; } }

    /* Lower the base layers control */
    .leaflet-top.leaflet-right .leaflet-control-layers { margin-top: 75px !important; }

    /* Defensive */
    .leaflet-control-geocoder { display: none !important; }

    /* Street View panel */
    #sv-panel {
      position: absolute; z-index: 1100; right: 10px; bottom: 10px;
      width: 420px; height: 300px; background: #fff; border-radius: 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,.18); display: none; overflow: hidden;
      border: 1px solid #ddd;
    }
    #sv-header {
      height: 36px; display:flex; align-items:center; justify-content:space-between;
      padding: 0 10px; border-bottom: 1px solid #eee; background:#fafafa;
      font: 13px system-ui, sans-serif;
    }
    #sv-title { font-weight: 600; }
    #sv-actions button {
      margin-left: 6px; padding: 4px 8px; border: 1px solid #ddd; background:#fff; border-radius: 6px; cursor: pointer;
    }
    #pano { width: 100%; height: calc(100% - 36px); }
    #sv-panel { resize: both; }
  </style>
</head>
<body>
<div id="map">
  <!-- Unified Search + Drawing toolbar -->
  <div class="toolbar" id="ui-toolbar">
    <select id="mode" title="Search mode">
      <option value="postcode">Postcode / Address</option>
      <option value="latlon">Lat, Lon</option>
      <option value="en">Easting, Northing</option>
    </select>

    <input id="q" type="text" placeholder="SY3 0NS  |  52.677027, -2.773167  |  349000, 306000" />
    <button id="go">Search</button>

    <span class="spacer"></span>

    <button id="btn-export" title="Download drawings as GeoJSON">Export</button>
    <button id="btn-import" title="Load drawings from GeoJSON">Import</button>
    <input id="file-import" type="file" accept=".json,.geojson" style="display:none">

    <span class="spacer"></span>

    <button id="btn-edit-all" title="Enable edit mode for all shapes">Edit All</button>
    <button id="btn-drag"     title="Enable drag mode for shapes">Drag Mode</button>
    <button id="btn-finish"   title="Disable edit/drag modes">Finish Edit</button>

    <span class="spacer"></span>

    <!-- Street View openers -->
    <button id="btn-sv-center" title="Open Street View at map centre">Street View here</button>
    <button id="btn-sv-pin" title="Open Street View at last pin">Street View at Pin</button>

    <span class="spacer"></span>

    <!-- NEW: Routing controls -->
    <input id="route-start" class="mini" type="text" placeholder="Start: address / 52.6,-2.7 / 349000,306000" />
    <input id="route-end"   class="mini" type="text" placeholder="End: address / 52.7,-2.8 / 340000,300000" />
    <select id="route-mode" title="Travel mode">
      <option value="driving">Driving</option>
      <option value="walking">Walking</option>
      <option value="cycling">Cycling</option>
    </select>
    <button id="btn-pin-start" title="Use current pin as Start">Pin→Start</button>
    <button id="btn-pin-end" title="Use current pin as End">Pin→End</button>
    <button id="btn-swap" title="Swap start/end">Swap</button>
    <button id="btn-route" title="Calculate route">Route</button>
    <button id="btn-clear-route" title="Clear route">Clear</button>
  </div>

  <!-- Route summary -->
  <div class="routebox" id="routebox">
    <h4>ROUTE:</h4>
    <div class="row">Mode: <code id="r-mode">—</code></div>
    <div class="row">Distance: <code id="r-dist">—</code></div>
    <div class="row">Duration: <code id="r-dur">—</code></div>
    <div class="row" style="opacity:.8">Tips: Right-click sets Start (first), End (second). Drag start/end markers to tweak.</div>
  </div>

  <!-- Pin info panel -->
  <div class="info" id="info">
    <h4>LOCATION INFORMATION:</h4>
    <div class="row">Postcode: <code id="postcode">—</code></div>
    <div class="row">Lat/Lon: <code id="latlon">—</code></div>
    <div class="row">Easting/Northing: <code id="en">—</code></div>
    <div class="row" style="opacity:.8">Tips: Shift+Click to drop a pin. Alt+Click to open Street View. Drawing clicks won’t move the map.</div>
  </div>

  <!-- Polygon metrics panel -->
  <div class="metrics" id="metrics">
    <h4>DRAWN POLYGON INFORMATION:</h4>
    <div class="row">Type: <code id="m-type">—</code></div>
    <div class="row">Area: <code id="m-area">—</code></div>
    <div class="row">Perimeter: <code id="m-perim">—</code></div>
    <div class="row">Longest edge: <code id="m-longest">—</code></div>
    <div class="row" style="margin-top:8px;">
      <button id="btn-copy" class="btn">Copy Coords</button>
      <button id="btn-center-shape" class="btn">Center on Shape</button>
    </div>
  </div>

  <!-- Street View panel -->
  <div id="sv-panel">
    <div id="sv-header">
      <div id="sv-title">Street View</div>
      <div id="sv-actions">
        <button id="sv-popout" title="Open in Google Maps">Open in Maps</button>
        <button id="sv-close" title="Close Street View">Close</button>
      </div>
    </div>
    <div id="pano"></div>
  </div>
</div>
  
<script id="gmaps-loader">
  (function () {
    const STORAGE = 'gmapsApiKey';
    const paramKey = new URL(location.href).searchParams.get('gmaps');
    if (paramKey) localStorage.setItem(STORAGE, paramKey);
    const savedKey = localStorage.getItem(STORAGE);
  
    function inject(k) {
      if (!k) return;
      const s = document.createElement('script');
      s.src = 'https://maps.googleapis.com/maps/api/js?key=' + encodeURIComponent(k) + '&v=weekly&loading=async';
      s.async = true; s.defer = true;
      document.head.appendChild(s);
    }
  
    if (savedKey) {
      inject(savedKey);
      return;
    }
  
    // Minimal inline UI to capture key on first run
    const ui = document.createElement('div');
    ui.style.cssText = 'position:fixed;z-index:2000;left:50%;top:12px;transform:translateX(-50%);background:#fff;padding:10px 12px;border:1px solid #ddd;border-radius:10px;box-shadow:0 2px 12px rgba(0,0,0,.15);font:13px system-ui';
    ui.innerHTML = `
      <b>Google Maps API key needed</b>
      <div style="margin-top:6px;display:flex;gap:6px;align-items:center;">
        <input id="gmaps-key-input" type="password" placeholder="Paste key…" style="width:280px;padding:6px 8px;border:1px solid #ccc;border-radius:8px;">
        <button id="gmaps-key-save" style="padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#f7f7f7;cursor:pointer;">Save</button>
        <button id="gmaps-key-cancel" style="padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer;">Dismiss</button>
      </div>
      <div style="margin-top:6px;opacity:.75">
        Tip: you can also open with <code>?gmaps=YOUR_KEY</code>. The key is stored in <code>localStorage</code> on this browser only.
      </div>
    `;
    document.addEventListener('DOMContentLoaded', () => {
      document.body.appendChild(ui);
      document.getElementById('gmaps-key-save')?.addEventListener('click', () => {
        const val = document.getElementById('gmaps-key-input').value.trim();
        if (!val) return alert('Paste your Google Maps JavaScript API key.');
        localStorage.setItem(STORAGE, val);
        ui.remove();
        inject(val);
      });
      document.getElementById('gmaps-key-cancel')?.addEventListener('click', () => ui.remove());
    });
  
    // Helper for you: clear saved key via console when needed
    window.__clearGMapsKey = () => { localStorage.removeItem(STORAGE); location.reload(); };
  })();
</script>

  
<script type="module">
  // ---------- Config ----------
  const centre = [52.677027, -2.773167]; // 29 Green Lane, SY3 0NS
  proj4.defs('EPSG:27700', '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs');
  const WGS84 = 'EPSG:4326';
  const OSGB  = 'EPSG:27700';

  const byId = id => document.getElementById(id);
  const isNum = v => typeof v === 'number' && isFinite(v) && !isNaN(v);

  // ---------- Basemaps ----------
  const esriImagery = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 20, attribution: "Imagery © Esri" }
  );
  const esriLabels = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 20, attribution: "Labels © Esri" }
  );
  const osmStreets = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    { maxZoom: 20, attribution: "© OpenStreetMap contributors" }
  );

  // Map init with fallback
  const map = L.map("map", {
    center: centre,
    zoom: 19,
    layers: [esriImagery, esriLabels],
    fullscreenControl: true
  });

  // Prevent UI clicks from bubbling into the map
  function blockEventsFor(selector) {
    document.querySelectorAll(selector).forEach(el => {
      L.DomEvent.disableClickPropagation(el);
      L.DomEvent.disableScrollPropagation(el);
    });
  }
  blockEventsFor('#ui-toolbar, #metrics, #info, #sv-panel, #routebox');
  blockEventsFor('.leaflet-control-container');

  // Initial pin
  let pin = L.marker(centre).addTo(map).bindPopup("SY3 0NS").openPopup();

  // Elements for info panel
  const elPostcode = byId('postcode');
  const elLatLon = byId('latlon');
  const elEN = byId('en');

  // UK postcode normaliser/checker
  function normalizeUKPostcode(str) {
    if (!str) return null;
    const s = str.toUpperCase().replace(/\s+/g, '');
    return /^[A-Z]{1,2}\d[A-Z\d]?\d[A-Z]{2}$/.test(s) ? s : null;
  }

  // Update only coords + authoritative postcode (no Nominatim)
  async function updateInfo(lat, lon) {
    const latStr = lat.toFixed(6), lonStr = lon.toFixed(6);
    elLatLon.textContent = `${latStr}, ${lonStr}`;

    const [E, N] = proj4(WGS84, OSGB, [lon, lat]);
    elEN.textContent = `${Math.round(E)}, ${Math.round(N)}`;

    // Authoritative postcode near this lat/lon
    let pc = '—';
    try {
      const pr = await fetch(`https://api.postcodes.io/postcodes?lon=${lonStr}&lat=${latStr}&limit=1`);
      const pj = await pr.json();
      pc = pj?.result?.[0]?.postcode || '—';
    } catch {}
    elPostcode.textContent = pc;
    pin.setPopupContent(pc);
  }

  function setPin(lat, lon, recenter = false) {
    if (!isNum(lat) || !isNum(lon)) return;
    pin.setLatLng([lat, lon]);
    pin.addTo(map).openPopup();
    if (recenter) {
      map.setView([lat, lon], Math.max(map.getZoom(), 18));
    }
    updateInfo(lat, lon);
  }

  // Guard: ignore clicks that originate from UI/controls
  function clickCameFromUI(evt) {
    const t = evt.originalEvent?.target;
    return !!(t && t.closest && t.closest('.toolbar, .metrics, .info, .leaflet-control, #sv-panel, #routebox'));
  }

  // ---------- Google base (async ready) ----------
  async function ensureGoogle() {
    for (let i = 0; i < 400; i++) {
      if (window.google?.maps?.importLibrary) break;
      await new Promise(r => setTimeout(r, 25));
    }
    if (!window.google?.maps?.importLibrary) throw new Error('Google Maps JS API not ready');
    await google.maps.importLibrary("maps");
  }

  try {
    await ensureGoogle();
    const gRoad   = L.gridLayer.googleMutant({ type: "roadmap",   maxZoom: 21 });
    const gHybrid = L.gridLayer.googleMutant({ type: "hybrid",    maxZoom: 21 });
    const gSat    = L.gridLayer.googleMutant({ type: "satellite", maxZoom: 21 });

    map.addLayer(gHybrid); // default to Hybrid

    const baseMaps = {
      "Google Roadmap": gRoad,
      "Google Hybrid":  gHybrid,
      "Google Satellite": gSat,
      "Esri Satellite (fallback)": esriImagery,
      "OSM Streets (fallback)": osmStreets
    };
    const overlays = { "Esri Labels (for Esri Hybrid)": esriLabels };
    L.control.layers(baseMaps, overlays, { collapsed: false }).addTo(map);

  } catch (e) {
    console.warn('Google base unavailable, staying on Esri/OSM.', e);
    L.control.layers(
      { "Esri Satellite": esriImagery, "OSM Streets": osmStreets },
      { "Esri Labels (Hybrid)": esriLabels },
      { collapsed: false }
    ).addTo(map);
  }

  // ---------- Unified Search ----------
  byId('mode').addEventListener('change', () => {
    const m = byId('mode').value;
    byId('q').placeholder =
      m === 'postcode' ? 'SY3 0NS  |  10 Downing Street' :
      m === 'latlon'   ? '52.677027, -2.773167' :
                         '349000, 306000';
  });

  byId('go').addEventListener('click', runUnifiedSearch);
  byId('q').addEventListener('keydown', e => { if (e.key === 'Enter') runUnifiedSearch(); });

  async function runUnifiedSearch() {
    const mode = byId('mode').value;
    const raw  = byId('q').value.trim();
    if (!raw) return;

    if (mode === 'latlon') {
      const parts = raw.split(/[,\s]+/).filter(Boolean);
      if (parts.length !== 2) return alert('Use: 52.677027, -2.773167');
      const lat = parseFloat(parts[0]), lon = parseFloat(parts[1]);
      if (!isNum(lat) || !isNum(lon)) return alert('Invalid lat/lon.');
      setPin(lat, lon, true); return;
    }

    if (mode === 'en') {
      const parts = raw.split(/[,\s]+/).filter(Boolean);
      if (parts.length !== 2) return alert('Use: 349000, 306000 (E,N)');
      const E = parseFloat(parts[0]), N = parseFloat(parts[1]);
      if (!isNum(E) || !isNum(N)) return alert('Invalid Easting/Northing.');
      const [lon, lat] = proj4(OSGB, WGS84, [E, N]);
      setPin(lat, lon, true); return;
    }

    // Postcode / Address mode
    try {
      const norm = normalizeUKPostcode(raw);
      if (norm) {
        const resp = await fetch(`https://api.postcodes.io/postcodes/${norm}`);
        const j = await resp.json();
        if (j && j.status === 200 && j.result) {
          const { latitude: lat, longitude: lon } = j.result;
          setPin(lat, lon, true);
          return;
        } else {
          alert('Postcode not found in postcodes.io; falling back to address search.');
        }
      }
      // Fallback: Nominatim for coordinates only
      const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(raw)}&countrycodes=gb&limit=1&accept-language=en-GB`;
      const r = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const j = await r.json();
      if (j && j.length) {
        const { lat, lon, boundingbox } = j[0];
        setPin(parseFloat(lat), parseFloat(lon), true);
        if (boundingbox) {
          const bb = [[+boundingbox[0], +boundingbox[2]],[+boundingbox[1], +boundingbox[3]]];
          map.fitBounds(bb, { maxZoom: 19 });
        }
      } else alert('No results.');
    } catch { alert('Search failed (network or rate limit).'); }
  }

  // --- Keep map still while drawing (polygon-only dblclick handling) ---
  let isDrawing = false;

  map.on('pm:drawstart', (e) => {
    isDrawing = true;
    if (e.shape === 'Polygon') {
      map.doubleClickZoom.disable();  // double-click closes polygon
    }
  });
  map.on('pm:drawend', () => {
    isDrawing = false;
    map.doubleClickZoom.enable();
  });
  map.on('pm:create', () => {
    isDrawing = false;
    map.doubleClickZoom.enable();
  });

  // Pin-placement (Shift+Click only)
  map.on('click', e => {
    if (clickCameFromUI(e)) return;
    if (isDrawing) return;
    if (map.pm.globalDrawModeEnabled && map.pm.globalDrawModeEnabled()) return;
    if (map.pm.globalEditEnabled && map.pm.globalEditEnabled()) return;
    if (map.pm.globalDragModeEnabled && map.pm.globalDragModeEnabled()) return;
    if (!e.originalEvent || !e.originalEvent.shiftKey) return;
    setPin(e.latlng.lat, e.latlng.lng, false);
  });

  // ---------- Geoman drawing & EDITING + Metrics ----------
  const defaultStyle = { color: "#00AEEF", weight: 2, fillOpacity: 0.18 };
  const activeStyle  = { color: "#007ACC", weight: 2, fillOpacity: 0.20 };

  map.pm.setGlobalOptions({
    snappable: true,
    snapDistance: 20,
    allowSelfIntersection: false,
    continueDrawing: false,
    finishOn: 'dblclick'
  });

  map.pm.addControls({
    position: "topleft",
    drawMarker: true,
    drawPolyline: true,
    drawRectangle: true,
    drawPolygon: true,
    drawCircle: true,
    drawCircleMarker: true,
    editMode: true,
    dragMode: true,
    cutPolygon: true,
    removalMode: true
  });

  let selectedLayer = null;   // last thing clicked (if shape)
  let lastShapeLayer = null;  // last POLYGON/CIRCLE

  const mType  = byId('m-type');
  const mArea  = byId('m-area');
  const mPerim = byId('m-perim');
  const mLongest = byId('m-longest');

  function isPolygonish(layer) {
    return (layer instanceof L.Polygon) || (layer instanceof L.Circle);
  }

  function updateMetrics(layer) {
    if (!layer || !isPolygonish(layer)) {
      mType.textContent='—'; mArea.textContent='—'; mPerim.textContent='—';
      if (mLongest) mLongest.textContent = '—';
      return;
    }

    if (layer instanceof L.Circle) {
      const r = layer.getRadius();
      const area = Math.PI * r * r;
      const peri = 2 * Math.PI * r;
      mType.textContent = 'Circle';
      mArea.textContent = `${area.toFixed(0)} m²  (${(area/10000).toFixed(4)} ha)`;
      mPerim.textContent = `${peri.toFixed(2)} m`;
      if (mLongest) mLongest.textContent = '—';
      return;
    }
    try {
      const gj = layer.toGeoJSON();
      const type = gj.geometry?.type || 'Feature';
      mType.textContent = type;
      if (type === 'Polygon' || type === 'MultiPolygon') {
        const area = turf.area(gj);
        const outline = turf.polygonToLine(gj);
        const lengthKm = turf.length(outline, { units: 'kilometers' });
        const peri = lengthKm * 1000;
        mArea.textContent = `${area.toFixed(0)} m²  (${(area/10000).toFixed(4)} ha)`;
        mPerim.textContent = `${peri.toFixed(2)} m`;

        // Longest edge
        if (mLongest) {
          const longest = longestEdgeMetersFromGeom(gj.geometry);
          mLongest.textContent = `${longest.toFixed(2)} m`;
        }
      } else {
        mArea.textContent = `—`; mPerim.textContent = `—`;
        if (mLongest) mLongest.textContent = '—';
      }
    } catch {
      mType.textContent='—'; mArea.textContent='—'; mPerim.textContent='—';
      if (mLongest) mLongest.textContent='—';
    }
  }

  function setSelected(layer) {
    if (selectedLayer && selectedLayer.setStyle && isPolygonish(selectedLayer)) {
      selectedLayer.setStyle(defaultStyle);
    }
    selectedLayer = layer;
    if (selectedLayer && selectedLayer.setStyle && isPolygonish(selectedLayer)) {
      selectedLayer.setStyle(activeStyle);
    }
    if (isPolygonish(layer)) {
      lastShapeLayer = layer;
      updateMetrics(layer);
    } else {
      updateMetrics(null);
    }
  }

  function bindEditableHandlers(layer, isImported = false) {
    if (layer.setStyle && !isImported && isPolygonish(layer)) layer.setStyle(defaultStyle);

    if (isPolygonish(layer)) {
      layer.on('click', () => {
        setSelected(layer);
        if (layer.pm) {
          if (layer.pm.enabled()) layer.pm.disable();
          else layer.pm.enable({ allowSelfIntersection: false, snappable: true, snapDistance: 20 });
        }
      });

      layer.on('pm:edit',   () => updateMetrics(layer));
      layer.on('pm:dragend',() => updateMetrics(layer));
      layer.on('pm:enable', () => { if (layer.setStyle) layer.setStyle(activeStyle); });
      layer.on('pm:disable',() => { if (layer.setStyle) layer.setStyle(defaultStyle); updateMetrics(layer); });

      updateMetrics(layer);
    }
  }

  map.on("pm:create", e => {
    const layer = e.layer;
    if (layer.setStyle && isPolygonish(layer)) layer.setStyle(defaultStyle);
    if (layer.pm && layer.pm.enable && isPolygonish(layer)) {
      layer.pm.enable({ allowSelfIntersection: false, snappable: true, snapDistance: 20 });
    }
    bindEditableHandlers(layer);
    if (isPolygonish(layer)) setSelected(layer);
    console.log("Created feature:", layer.toGeoJSON());
  });

  map.eachLayer(l => { if (l.pm) bindEditableHandlers(l); });

  byId('btn-edit-all').onclick = () => { map.pm.toggleGlobalEditMode(); };
  byId('btn-drag').onclick     = () => { map.pm.toggleGlobalDragMode(); };
  byId('btn-finish').onclick   = () => {
    if (map.pm.globalEditEnabled()) map.pm.toggleGlobalEditMode();
    if (map.pm.globalDragModeEnabled && map.pm.globalDragModeEnabled()) map.pm.toggleGlobalDragMode();
    map.eachLayer(l => { if (l.pm && l.pm.enabled && l.pm.enabled()) l.pm.disable(); });
    if (lastShapeLayer) updateMetrics(lastShapeLayer);
  };

  // ---------- Copy coords & Center buttons ----------
  const btnCopy = byId('btn-copy');
  const btnCenterShape = byId('btn-center-shape');

  btnCopy.addEventListener('click', async () => {
    if (!lastShapeLayer) { alert('Draw or select a polygon/circle first.'); return; }
    try {
      const text = buildCoordsText(lastShapeLayer);
      await copyText(text);
      flashBtn(btnCopy, 'Copied!');
    } catch (err) {
      console.error(err);
      alert('Failed to copy.');
    }
  });

  btnCenterShape.addEventListener('click', () => {
    if (lastShapeLayer && isPolygonish(lastShapeLayer)) {
      if (lastShapeLayer instanceof L.Circle) {
        const c = lastShapeLayer.getLatLng();
        map.flyTo(c, Math.max(map.getZoom(), 18));
      } else {
        const b = lastShapeLayer.getBounds();
        map.fitBounds(b, { maxZoom: Math.max(map.getZoom(), 19) });
      }
    } else if (pin) {
      map.flyTo(pin.getLatLng(), Math.max(map.getZoom(), 18));
    }
  });

  function buildCoordsText(layer) {
    if (layer instanceof L.Circle) {
      const c = layer.getLatLng();
      const rMeters = layer.getRadius();
      const poly = turf.circle([c.lng, c.lat], rMeters / 1000, { steps: 64, units: 'kilometers' });
      return JSON.stringify(poly.geometry.coordinates);
    }
    const gj = layer.toGeoJSON();
    const geom = gj && gj.geometry ? gj.geometry : null;
    if (!geom) throw new Error('No geometry found.');
    if (!(geom.type === 'Polygon' || geom.type === 'MultiPolygon')) {
      throw new Error('Only polygons/circles are exported here.');
    }
    return JSON.stringify(geom.coordinates);
  }

  async function copyText(text) {
    if (navigator.clipboard?.writeText) return navigator.clipboard.writeText(text);
    const ta = document.createElement('textarea');
    ta.value = text; ta.style.position = 'fixed'; ta.style.top = '-9999px';
    document.body.appendChild(ta); ta.focus(); ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
  }

  function flashBtn(btn, msg) {
    const orig = btn.textContent;
    btn.textContent = msg; btn.disabled = true;
    setTimeout(() => { btn.textContent = orig; btn.disabled = false; }, 1200);
  }

  function longestEdgeMetersFromGeom(geom) {
    let longest = 0;
    const processRing = (ring) => {
      const n = ring.length;
      if (n < 2) return;
      for (let i = 0; i < n; i++) {
        const a = ring[i];
        const b = ring[(i + 1) % n];
        const km = turf.distance(a, b, { units: 'kilometers' });
        const m = km * 1000;
        if (m > longest) longest = m;
      }
    };
    if (geom.type === 'Polygon') {
      geom.coordinates.forEach(processRing);
    } else if (geom.type === 'MultiPolygon') {
      geom.coordinates.forEach(poly => poly.forEach(processRing));
    }
    return longest;
  }

  // ---------- Street View integration ----------
  let svService = null;
  let panorama = null;
  const svPanel = byId('sv-panel');
  const svTitle = byId('sv-title');
  const svBtnClose = byId('sv-close');
  const svBtnPop = byId('sv-popout');
  const btnSVHere = byId('btn-sv-center');
  const btnSVPin  = byId('btn-sv-pin');

  function showSVPanel(show) {
    svPanel.style.display = show ? 'block' : 'none';
  }

  function ensureSV() {
    if (!window.google || !google.maps) return false;
    if (!svService) svService = new google.maps.StreetViewService();
    if (!panorama) {
      panorama = new google.maps.StreetViewPanorama(byId('pano'), {
        addressControl: true,
        linksControl: true,
        panControl: true,
        zoomControl: true,
        fullscreenControl: true
      });
    }
    return true;
  }

  function openSVAt(lat, lon) {
    if (!ensureSV()) return alert('Google Maps API not ready');
    const loc = { lat, lng: lon };
    svService.getPanorama({ location: loc, radius: 70 }, (data, status) => {
      if (status === 'OK' && data && data.location) {
        panorama.setPano(data.location.pano);
        panorama.setPov({ heading: 0, pitch: 0 });
        panorama.setVisible(true);
        svTitle.textContent = 'Street View';
        svBtnPop.onclick = () => {
          const url = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${data.location.latLng.lat()},${data.location.latLng.lng()}`;
          window.open(url, '_blank', 'noopener');
        };
        showSVPanel(true);
      } else {
        alert('No Street View available at this location.');
      }
    });
  }

  btnSVHere.addEventListener('click', () => {
    const c = map.getCenter();
    openSVAt(c.lat, c.lng);
  });

  btnSVPin.addEventListener('click', () => {
    const ll = pin.getLatLng();
    openSVAt(ll.lat, ll.lng);
  });

  map.on('click', (e) => {
    if (clickCameFromUI(e)) return;
    if (e.originalEvent && e.originalEvent.altKey) {
      openSVAt(e.latlng.lat, e.latlng.lng);
    }
  });

  map.on('contextmenu', (e) => {
    // Right-click quick routing: set start if empty, else set end
    if (!routeState.start) {
      setRoutePoint('start', e.latlng.lat, e.latlng.lng, 'Right-click Start');
    } else {
      setRoutePoint('end', e.latlng.lat, e.latlng.lng, 'Right-click End');
    }
  });

  svBtnClose.addEventListener('click', () => showSVPanel(false));

  // ---------- Routing (OSRM demo server) ----------
  const routeLayer = L.layerGroup().addTo(map);
  let startMarker = null, endMarker = null;

  const elRS = byId('route-start');
  const elRE = byId('route-end');
  const elRM = byId('route-mode');
  const btnPinStart = byId('btn-pin-start');
  const btnPinEnd   = byId('btn-pin-end');
  const btnSwap     = byId('btn-swap');
  const btnRoute    = byId('btn-route');
  const btnClearRt  = byId('btn-clear-route');

  const rMode = byId('r-mode');
  const rDist = byId('r-dist');
  const rDur  = byId('r-dur');

  const routeState = { start: null, end: null }; // {lat, lon, label}

  function updateRouteSummary(mode = '—', distM = null, durS = null) {
    rMode.textContent = mode;
    rDist.textContent = distM != null ? `${(distM/1000).toFixed(2)} km` : '—';
    if (durS != null) {
      const mins = Math.round(durS/60);
      const hrs = Math.floor(mins/60);
      const rem = mins % 60;
      rDur.textContent = hrs ? `${hrs}h ${rem}m` : `${mins} min`;
    } else {
      rDur.textContent = '—';
    }
  }

  function setRoutePoint(which, lat, lon, label = '') {
    const obj = { lat, lon, label };
    routeState[which] = obj;
    const formatted = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
    if (which === 'start') {
      elRS.value = label ? `${label} (${formatted})` : formatted;
      if (startMarker) startMarker.setLatLng([lat,lon]);
      else {
        startMarker = L.marker([lat,lon], { draggable: true }).addTo(routeLayer).bindPopup('Start');
        startMarker.on('dragend', () => {
          const p = startMarker.getLatLng();
          routeState.start = { lat: p.lat, lon: p.lng, label: 'Dragged Start' };
          elRS.value = `${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`;
        });
      }
    } else {
      elRE.value = label ? `${label} (${formatted})` : formatted;
      if (endMarker) endMarker.setLatLng([lat,lon]);
      else {
        endMarker = L.marker([lat,lon], { draggable: true }).addTo(routeLayer).bindPopup('End');
        endMarker.on('dragend', () => {
          const p = endMarker.getLatLng();
          routeState.end = { lat: p.lat, lon: p.lng, label: 'Dragged End' };
          elRE.value = `${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`;
        });
      }
    }
  }

  btnPinStart.addEventListener('click', () => {
    const p = pin.getLatLng();
    setRoutePoint('start', p.lat, p.lng, 'Pin');
  });
  btnPinEnd.addEventListener('click', () => {
    const p = pin.getLatLng();
    setRoutePoint('end', p.lat, p.lng, 'Pin');
  });

  btnSwap.addEventListener('click', () => {
    const a = routeState.start, b = routeState.end;
    routeState.start = b; routeState.end = a;
    const tmp = elRS.value; elRS.value = elRE.value; elRE.value = tmp;
    if (startMarker && b) startMarker.setLatLng([b.lat, b.lon]);
    if (endMarker && a)   endMarker.setLatLng([a.lat, a.lon]);
  });

  btnClearRt.addEventListener('click', clearRoute);
  function clearRoute() {
    routeLayer.clearLayers();
    startMarker = endMarker = null;
    routeState.start = routeState.end = null;
    elRS.value = ''; elRE.value = '';
    updateRouteSummary('—', null, null);
  }

  btnRoute.addEventListener('click', planRoute);

  // Smart parser: lat,lon | E,N | postcode | address
  async function resolvePoint(text) {
    const raw = (text || '').trim();
    if (!raw) return null;

    // Try lat,lon
    const parts = raw.replace(/[()]/g,'').split(/[,\s]+/).filter(Boolean);
    if (parts.length === 2 && !isNaN(+parts[0]) && !isNaN(+parts[1])) {
      const a = parseFloat(parts[0]), b = parseFloat(parts[1]);
      // Heuristic: if both > 1000, treat as E/N
      if (Math.abs(a) > 1000 && Math.abs(b) > 1000) {
        const [lon, lat] = proj4(OSGB, WGS84, [a, b]);
        return { lat, lon, label: 'E/N' };
      }
      // else assume lat,lon in degrees
      if (Math.abs(a) <= 90 && Math.abs(b) <= 180) {
        return { lat: a, lon: b, label: 'Lat/Lon' };
      }
    }

    // Postcode
    const maybePC = normalizeUKPostcode(raw);
    if (maybePC) {
      try {
        const r = await fetch(`https://api.postcodes.io/postcodes/${maybePC}`);
        const j = await r.json();
        if (j?.status === 200 && j.result) {
          return { lat: j.result.latitude, lon: j.result.longitude, label: j.result.postcode };
        }
      } catch {}
    }

    // Fallback: Nominatim (UK-biased)
    try {
      const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(raw)}&countrycodes=gb&limit=1&accept-language=en-GB`;
      const r = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const j = await r.json();
      if (j && j.length) {
        return { lat: +j[0].lat, lon: +j[0].lon, label: j[0].display_name?.split(',')[0] || 'Address' };
      }
    } catch {}
    return null;
  }

  async function planRoute() {
    try {
      // Resolve start
      if (!routeState.start) {
        const s = await resolvePoint(elRS.value);
        if (!s) return alert('Set a valid Start (address/postcode/lat,lon/E,N).');
        setRoutePoint('start', s.lat, s.lon, s.label);
      }
      // Resolve end
      if (!routeState.end) {
        const e = await resolvePoint(elRE.value);
        if (!e) return alert('Set a valid End (address/postcode/lat,lon/E,N).');
        setRoutePoint('end', e.lat, e.lon, e.label);
      }

      const { start, end } = routeState;
      if (!start || !end) return;

      const profile = elRM.value; // driving | walking | cycling
      const url = `https://router.project-osrm.org/route/v1/${profile}/${start.lon},${start.lat};${end.lon},${end.lat}?overview=full&geometries=geojson&alternatives=false&steps=false`;

      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`Routing failed (${resp.status})`);
      const data = await resp.json();
      if (!data || !data.routes || !data.routes.length) throw new Error('No route returned.');

      // Clear previous line, keep markers
      routeLayer.eachLayer(l => {
        if (!(l === startMarker || l === endMarker)) routeLayer.removeLayer(l);
      });

      const route = data.routes[0];
      const coords = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
      const line = L.polyline(coords, { weight: 5, opacity: 0.85 }).addTo(routeLayer);
      map.fitBounds(line.getBounds(), { padding: [30,30] });

      updateRouteSummary(profile, route.distance, route.duration);
    } catch (err) {
      console.error(err);
      alert('Could not compute route (network/limits/unreachable). Try another mode or simplify the points.');
    }
  }

  // ---------- Initial pin info ----------
  (async () => { await updateInfo(centre[0], centre[1]); })();
</script>

<noscript>Enable JavaScript to view the map.</noscript>
</body>
</html>
