<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <title>Leaflet — Two Fastest by Endpoint Direction (Road-True)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Fullscreen -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.css">
  <script src="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.js"></script>

  <!-- Leaflet.Geoman -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css">
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js"></script>

  <!-- Proj4 + Turf -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100vh; position: relative; }

    .toolbar {
      position: absolute; z-index: 1500; top: 10px; left: 60px; right: 10px;
      background: #fff; border-radius: 12px; padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,.18); font: 14px system-ui, sans-serif;
      display: flex; align-items: center; gap: 8px; overflow-x: auto; white-space: nowrap;
    }
    .toolbar input, .toolbar button, .toolbar label { padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; }
    .mini { width: 240px; }
    .leaflet-control { z-index: 1200 !important; }

    .bottom-dock { position:absolute; z-index:1400; left:10px; right:10px; bottom:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .card { background:#fff; border-radius:10px; padding:10px 12px; box-shadow:0 2px 10px rgba(0,0,0,.18); font:13px system-ui; }
    .routebox { min-width: 420px; max-width: 960px; flex: 1 1 600px; }
    .route-item { display:flex; align-items:center; gap:8px; padding:6px 8px; border:1px solid #eee; border-radius:8px; margin:6px 0; cursor:pointer; }
    .route-item.active { border-color:#bbb; background:#fafafa; }
    .route-swatch { width:14px; height:14px; border-radius:3px; border:1px solid #bbb; }
    .btn { padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; background: #f7f7f7; cursor: pointer; }
  </style>
</head>
<body>
<div id="map">
  <div class="toolbar">
    <button id="toggle-panels" title="Show/Hide routes">Panels</button>
    <input id="route-start" class="mini" type="text" placeholder="Start: address / 52.6,-2.7 / 349000,306000" />
    <input id="route-end"   class="mini" type="text" placeholder="End: address / 52.7,-2.8 / 340000,300000" />
    <button id="btn-pin-start" title="Use pin as Start">Pin→Start</button>
    <button id="btn-pin-end" title="Use pin as End">Pin→End</button>
    <button id="btn-swap" title="Swap start/end">Swap</button>
    <button id="btn-route" title="Calculate routes">Route</button>
    <button id="btn-clear-route" title="Clear routes">Clear</button>
  </div>

  <div class="bottom-dock" id="bottom-dock">
    <div class="card routebox" id="routebox">
      <h4>ROUTES (Two fastest by endpoint direction):</h4>
      <div id="r-list"></div>
      <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
        <button id="btn-use-selected" class="btn" title="Add selected route to drawings">Use Selected</button>
        <button id="btn-copy-selected" class="btn" title="Copy selected route coordinates">Copy Coords</button>
        <button id="btn-zoom-all" class="btn" title="Zoom to all routes">Zoom All</button>
      </div>
      <div style="opacity:.75">Right-click to set Start/End • Shift+Click to move pin • Exactly two routes when the endpoint has two viable directions; otherwise one.</div>
    </div>
  </div>
</div>

<script type="module">
  // ---- Basic map + layers ----
  const centre = [52.677027, -2.773167];
  const map = L.map("map", { center: centre, zoom: 18, layers: [], fullscreenControl: true });
  const esriImagery = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {maxZoom:20, attribution:"Imagery © Esri"}).addTo(map);
  const esriLabels  = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}", {maxZoom:20, attribution:"Labels © Esri"}).addTo(map);
  L.control.layers({ "Esri Satellite": esriImagery }, { "Esri Labels": esriLabels }, { collapsed: false }).addTo(map);

  // Prevent UI from eating map gestures
  (function block(selector){ document.querySelectorAll(selector).forEach(el=>{ L.DomEvent.disableClickPropagation(el); L.DomEvent.disableScrollPropagation(el); }); })('.toolbar, #bottom-dock, .leaflet-control-container');

  // Pin
  let pin = L.marker(centre).addTo(map).bindPopup("Pin").openPopup();
  function setPin(lat,lon, recenter=false){ pin.setLatLng([lat,lon]).openPopup(); if(recenter) map.setView([lat,lon], Math.max(map.getZoom(),18)); }

  // Inputs
  const byId=id=>document.getElementById(id);
  const elRS=byId('route-start'), elRE=byId('route-end');
  byId('toggle-panels').onclick = () => {
    const dock = byId('bottom-dock');
    dock.style.display = (dock.style.display==='none' ? 'flex' : 'none');
  };

  // Drawing (keep lightweight, optional)
  map.pm.addControls({ position:"topleft", drawMarker:false, drawPolyline:true, drawRectangle:true, drawPolygon:true, drawCircle:false, editMode:true, dragMode:true, cutPolygon:false, removalMode:true });

  // Route layer + state
  const routeLayer=L.layerGroup().addTo(map);
  const routeState={ start:null, end:null, polylines:[], labels:[], meta:[], activeIdx:-1 };
  const PALETTE=['#e53935','#1e88e5'];
  const rList=byId('r-list');

  // --- Helpers: parsing & snapping ---
  proj4.defs('EPSG:27700','+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs');
  const WGS84='EPSG:4326', OSGB='EPSG:27700';

  function normalizeUKPostcode(str){ if(!str) return null; const s=str.toUpperCase().replace(/\s+/g,''); return /^[A-Z]{1,2}\d[A-Z\d]?\d[A-Z]{2}$/.test(s)?s:null; }
  async function resolvePoint(text){
    const raw=(text||'').trim(); if(!raw) return null;
    const parts=raw.replace(/[()]/g,'').split(/[,\s]+/).filter(Boolean);
    if(parts.length===2 && !isNaN(+parts[0]) && !isNaN(+parts[1])){
      const a=+parts[0], b=+parts[1];
      if(Math.abs(a)>1000 && Math.abs(b)>1000){ const [lon,lat]=proj4(OSGB,WGS84,[a,b]); return {lat,lon,label:'E/N'}; }
      if(Math.abs(a)<=90 && Math.abs(b)<=180){ return {lat:a,lon:b,label:'Lat/Lon'}; }
    }
    const maybePC=normalizeUKPostcode(raw);
    if(maybePC){ try{ const r=await fetch(`https://api.postcodes.io/postcodes/${maybePC}`); const j=await r.json(); if(j?.status===200&&j.result) return {lat:j.result.latitude, lon:j.result.longitude, label:j.result.postcode}; }catch{} }
    try{
      const url=`https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(raw)}&countrycodes=gb&limit=1&accept-language=en-GB`;
      const r=await fetch(url,{headers:{'Accept':'application/json'}}); const j=await r.json();
      if(j&&j.length) return {lat:+j[0].lat, lon:+j[0].lon, label:(j[0].display_name||'').split(',')[0]||'Address'};
    }catch{}
    return null;
  }

  async function osrmNearest(lat,lon){
    try{
      const url = `https://router.project-osrm.org/nearest/v1/driving/${lon},${lat}`;
      const j = await fetch(url).then(r=>r.json());
      const loc = j?.waypoints?.[0]?.location;
      if (Array.isArray(loc) && loc.length===2) return { lat: loc[1], lon: loc[0] };
    }catch{}
    return { lat, lon };
  }
  async function snapPoint(p){ const s=await osrmNearest(p.lat,p.lon); return { ...p, lat:s.lat, lon:s.lon }; }

  // Multi-nearest to find two distinct anchors at endpoint (two possible directions)
  async function osrmNearestMulti(lat, lon, count = 4) {
    try {
      const url = `https://router.project-osrm.org/nearest/v1/driving/${lon},${lat}?number=${count}`;
      const j = await fetch(url).then(r => r.json());
      const wps = j?.waypoints || [];
      return wps.map(w => Array.isArray(w?.location) ? { lat: w.location[1], lon: w.location[0] } : null).filter(Boolean);
    } catch { return []; }
  }
  function dedupeByMeters(points, tolMeters = 10) {
    const out = [];
    for (const p of points) {
      const ok = out.every(q => {
        const m = turf.distance([p.lon,p.lat],[q.lon,q.lat],{units:'kilometers'})*1000;
        return m > tolMeters;
      });
      if (ok) out.push(p);
    }
    return out;
  }
  async function endpointAnchors(endLat, endLon){
    const raw = await osrmNearestMulti(endLat, endLon, 4);
    const uniq = dedupeByMeters(raw, 8);
    // Filter out the exact snapped point (within 1 m)
    const filtered = uniq.filter(p => (turf.distance([p.lon,p.lat],[endLon,endLat],{units:'kilometers'})*1000) > 1.0);
    // Pick two closest distinct anchors; if only one exists → cul-de-sac
    filtered.sort((a,b)=>{
      const da = turf.distance([a.lon,a.lat],[endLon,endLat],{units:'kilometers'});
      const db = turf.distance([b.lon,b.lat],[endLon,endLat],{units:'kilometers'});
      return da - db;
    });
    return filtered.slice(0,2);
  }

  // OSRM routing
  async function fetchOSRM(start, end, vias=[]){
    const coords = [[start.lon,start.lat], ...vias.map(v=>[v.lon,v.lat]), [end.lon,end.lat]]
      .map(pair=>pair.join(',')).join(';');
    const params = new URLSearchParams({ overview:'full', geometries:'geojson', alternatives:'false', steps:'false' });
    const url = `https://router.project-osrm.org/route/v1/driving/${coords}?${params}`;
    const j = await fetch(url).then(r=>r.json()).catch(()=>null);
    if (!j||!j.routes) return null;
    const rt = j.routes[0];
    return { distance: rt.distance, duration: rt.duration, coords: rt.geometry.coordinates.map(([lon,lat])=>[lat,lon]) };
  }

  // UI: markers + actions
  let startMarker=null, endMarker=null;
  function setRoutePoint(which, lat, lon, label=''){
    const obj={lat,lon,label};
    if(which==='start'){
      routeState.start=obj;
      elRS.value = label ? `${label} (${lat.toFixed(6)}, ${lon.toFixed(6)})` : `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
      if(startMarker) startMarker.setLatLng([lat,lon]); else startMarker=L.marker([lat,lon],{draggable:true}).addTo(routeLayer).bindPopup('Start');
    } else {
      routeState.end=obj;
      elRE.value = label ? `${label} (${lat.toFixed(6)}, ${lon.toFixed(6)})` : `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
      if(endMarker) endMarker.setLatLng([lat,lon]); else endMarker=L.marker([lat,lon],{draggable:true}).addTo(routeLayer).bindPopup('End');
    }
  }
  byId('btn-pin-start').addEventListener('click',async()=>{ const p=pin.getLatLng(); const s=await snapPoint({lat:p.lat,lon:p.lng,label:'Pin'}); setRoutePoint('start',s.lat,s.lon,'Pin'); });
  byId('btn-pin-end').addEventListener('click',async()=>{ const p=pin.getLatLng(); const s=await snapPoint({lat:p.lat,lon:p.lng,label:'Pin'}); setRoutePoint('end',s.lat,s.lon,'Pin'); });
  byId('btn-swap').addEventListener('click',()=>{ const a=routeState.start, b=routeState.end; routeState.start=b; routeState.end=a; const tmp=elRS.value; elRS.value=elRE.value; elRE.value=tmp; if(startMarker&&b) startMarker.setLatLng([b.lat,b.lon]); if(endMarker&&a) endMarker.setLatLng([a.lat,a.lon]); });

  map.on('contextmenu', e=>{ if(!routeState.start) setRoutePoint('start',e.latlng.lat,e.latlng.lng,'Start'); else setRoutePoint('end',e.latlng.lat,e.latlng.lng,'End'); });
  map.on('click', e=>{ if(e.originalEvent?.shiftKey){ setPin(e.latlng.lat,e.latlng.lng,false); } });

  function clearRoutes(){
    routeLayer.clearLayers();
    if(startMarker) startMarker.addTo(routeLayer).bindPopup('Start');
    if(endMarker) endMarker.addTo(routeLayer).bindPopup('End');
    routeState.polylines=[]; routeState.labels=[]; routeState.meta=[]; routeState.activeIdx=-1;
    rList.innerHTML='';
  }

  function hashCoords(coords){ const rounded = coords.map(ll=>[+ll[0].toFixed(5), +ll[1].toFixed(5)]); return JSON.stringify([rounded.length, rounded.slice(0,200)]); }
  function midpoint(latlngs){ return latlngs[Math.floor(latlngs.length/2)]||latlngs[0]; }
  function makeBadge(n,color,at){ const icon=L.divIcon({ className:'route-badge', html:`<div style="background:${color};color:#fff;border-radius:50%;width:22px;height:22px;display:flex;align-items:center;justify-content:center;font:12px/22px system-ui;box-shadow:0 1px 4px rgba(0,0,0,.25);">${n}</div>`, iconSize:[22,22], iconAnchor:[11,11] }); return L.marker(at,{icon}); }
  function fmtDur(sec){ const m=Math.round(sec/60); const h=Math.floor(m/60); const r=m%60; return h?`${h}h ${r}m`:`${m} min`; }

  function addRouteToUI(route, label){
    const idx=routeState.polylines.length;
    const color=PALETTE[idx%PALETTE.length];
    const poly=L.polyline(route.coords,{color,weight:5,opacity:0.95}).addTo(routeLayer);
    const badge=makeBadge(idx+1,color,midpoint(route.coords)).addTo(routeLayer);

    const item=document.createElement('div'); item.className='route-item';
    item.innerHTML=`<div class="route-swatch" style="background:${color}"></div>
                    <div><b>${idx+1}.</b> ${ (route.distance/1000).toFixed(2) } km • ${ fmtDur(route.duration) }
                    <span style="opacity:.7;margin-left:6px;">${label}</span></div>`;
    item.onclick=()=>setActiveRoute(idx); poly.on('click',()=>setActiveRoute(idx));

    rList.appendChild(item);
    routeState.polylines.push(poly); routeState.labels.push(badge); routeState.meta.push({color,label, distance:route.distance, duration:route.duration});
  }

  function setActiveRoute(i){
    routeState.activeIdx=i;
    routeState.polylines.forEach((pl,ix)=>pl.setStyle({weight: ix===i?7:5, opacity: ix===i?1:0.8, dashArray: ix===i?null:'6,6'}));
    const items=[...rList.querySelectorAll('.route-item')]; items.forEach((el,ix)=>el.classList.toggle('active',ix===i));
    const pl=routeState.polylines[i]; if(pl) map.fitBounds(pl.getBounds(),{padding:[30,30]});
  }

  // Core: plan exactly two routes forced by ENDPOINT direction
  async function planTwoByEndpointDirection(){
    // Parse inputs if not set
    if(!routeState.start){ const s = await resolvePoint(elRS.value); if(!s) return alert('Set a valid Start.'); routeState.start=s; }
    if(!routeState.end){   const e = await resolvePoint(elRE.value); if(!e) return alert('Set a valid End.');   routeState.end=e; }

    // Snap both to the nearest road
    const start = await snapPoint(routeState.start);
    const end   = await snapPoint(routeState.end);
    routeState.start=start; routeState.end=end;

    // Find up to two distinct on-road anchors around the END (endpoint)
    const anchors = await endpointAnchors(end.lat, end.lon);
    if (!anchors.length){
      // cul-de-sac or single approach only → just one route (no pre-end anchor)
      const r = await fetchOSRM(start,end);
      if(!r) return alert('No route found.');
      clearRoutes();
      addRouteToUI(r, 'Endpoint single approach');
      setActiveRoute(0);
      return;
    }

    clearRoutes();

    // Produce routes: Start → AnchorA → End (and AnchorB if exists)
    const first = await fetchOSRM(start, end, [anchors[0]]);
    if(first) addRouteToUI(first, 'Endpoint direction A');

    if(anchors[1]){
      const second = await fetchOSRM(start, end, [anchors[1]]);
      // De-dupe if geometry is identical
      if (second && hashCoords(second.coords)!==hashCoords(first?.coords||[])){
        addRouteToUI(second, 'Endpoint direction B');
      }
    }

    if (!routeState.polylines.length) return alert('No route candidates. The endpoint might be a hard dead-end.');
    setActiveRoute(0);
  }

  // Buttons
  byId('btn-route').addEventListener('click', planTwoByEndpointDirection);
  byId('btn-clear-route').addEventListener('click', clearRoutes);
  byId('btn-use-selected').addEventListener('click',()=>{
    const i=routeState.activeIdx; if(i==null||i<0) return alert('Select a route first.');
    const latlngs=routeState.polylines[i].getLatLngs(); const poly=L.polyline(latlngs,{color:'#007ACC',weight:3,opacity:1}).addTo(map);
    if(poly.pm&&poly.pm.enable) poly.pm.enable({snappable:true,snapDistance:20});
  });
  byId('btn-copy-selected').addEventListener('click', async ()=>{
    const i=routeState.activeIdx; if(i==null||i<0) return alert('Select a route first.');
    const latlngs=routeState.polylines[i].getLatLngs();
    const coords=latlngs.map(ll=>[ll.lng,ll.lat]);
    const text=JSON.stringify(coords);
    if(navigator.clipboard?.writeText) await navigator.clipboard.writeText(text);
    else { const ta=document.createElement('textarea'); ta.value=text; ta.style.position='fixed'; ta.style.top='-9999px'; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); }
  });
  byId('btn-zoom-all').addEventListener('click',()=>{
    const groups = routeState.polylines.filter(Boolean);
    if(!groups.length) return;
    let bounds = groups[0].getBounds();
    groups.slice(1).forEach(pl => bounds = bounds.extend(pl.getBounds()));
    map.fitBounds(bounds, {padding:[30,30]});
  });

  // Initial pin info + help
  setPin(centre[0], centre[1], false);
</script>

<noscript>Enable JavaScript to view the map.</noscript>
</body>
</html>
