<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <title>Leaflet + Car Navigation — Two-Way Start-from-End (Locked Directions)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Fullscreen -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.css">
  <script src="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.js"></script>

  <!-- Leaflet.Geoman -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css">
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js"></script>

  <!-- GoogleMutant -->
  <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.15.0/dist/Leaflet.GoogleMutant.js"></script>

  <!-- Proj4 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>

  <!-- Turf.js -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100vh; position: relative; }

    .toolbar {
      position: absolute; z-index: 1500; top: 10px; left: 60px; right: 10px;
      background: #fff; border-radius: 12px; padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,.18); font: 14px system-ui, sans-serif;
      display: flex; align-items: center; gap: 8px;
      flex-wrap: nowrap; white-space: nowrap;
      overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; scrollbar-width: thin;
    }
    .toolbar select, .toolbar input, .toolbar button, .toolbar label {
      padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; flex: 0 0 auto; cursor: pointer;
    }
    .toolbar label { display:flex; align-items:center; gap:6px; padding:4px 8px; }
    #q { min-width: 260px; flex: 1 1 320px; }
    .mini { width: 200px; }
    .toolbar .spacer { width: 6px; flex: 0 0 auto; }

    .leaflet-control { z-index: 1200 !important; }
    .leaflet-top.leaflet-right .leaflet-control-layers { margin-top: 120px !important; }

    .bottom-dock {
      position: absolute; z-index: 1400; left: 10px; right: 10px; bottom: 10px;
      display: flex; gap: 10px; align-items: stretch; flex-wrap: wrap;
    }
    .card { background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif; }
    .card h4 { margin: 0 0 6px 0; font-size: 14px; }
    .row { margin: 4px 0; }
    code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }

    .metrics { min-width: 280px; max-width: 420px; flex: 0 1 auto; }
    .routebox { min-width: 420px; max-width: 960px; flex: 1 1 600px; }
    .infobox { min-width: 280px; max-width: 360px; flex: 0 1 auto; }

    .btn { padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; background: #f7f7f7; cursor: pointer; }

    .route-item { display:flex; align-items:center; gap:8px; padding:6px 8px; border:1px solid #eee; border-radius:8px; margin:6px 0; cursor:pointer; }
    .route-swatch { width:14px; height:14px; border-radius:3px; border:1px solid #bbb; }
    .route-item.active { border-color:#bbb; background:#fafafa; }
    .provider-tag { font-size: 11px; opacity:.8; padding:2px 6px; border:1px solid #ddd; border-radius:6px; }

    .via-chip { display:inline-flex; align-items:center; gap:4px; padding:2px 6px; border:1px solid #ddd; border-radius:14px; margin-right:6px; }
    .via-chip button { border:none; background:transparent; cursor:pointer; }

    #sv-panel { position: absolute; z-index: 1450; right: 10px; bottom: 10px; width: 420px; height: 300px;
      background: #fff; border-radius: 10px; box-shadow: 0 2px 12px rgba(0,0,0,.18); display: none; overflow: hidden; border: 1px solid #ddd; resize: both; }
    #sv-header { height: 36px; display:flex; align-items:center; justify-content:space-between; padding: 0 10px; border-bottom: 1px solid #eee; background:#fafafa; font: 13px system-ui; }
    #sv-title { font-weight: 600; }
    #sv-actions button { margin-left: 6px; padding: 4px 8px; border: 1px solid #ddd; background:#fff; border-radius: 6px; cursor: pointer; }
    #pano { width: 100%; height: calc(100% - 36px); }
  </style>
</head>
<body>
<div id="map">
  <div class="toolbar" id="ui-toolbar">
    <button id="toggle-panels" title="Show/Hide bottom panels">Panels</button>

    <select id="mode" title="Search mode">
      <option value="postcode">Postcode / Address</option>
      <option value="latlon">Lat, Lon</option>
      <option value="en">Easting, Northing</option>
    </select>
    <input id="q" type="text" placeholder="SY3 0NS  |  52.677027, -2.773167  |  349000, 306000" />
    <button id="go">Search</button>

    <span class="spacer"></span>

    <button id="btn-export" title="Download drawings as GeoJSON">Export</button>
    <button id="btn-import" title="Load drawings from GeoJSON">Import</button>
    <input id="file-import" type="file" accept=".json,.geojson" style="display:none">

    <span class="spacer"></span>

    <button id="btn-edit-all" title="Enable edit mode for all shapes">Edit All</button>
    <button id="btn-drag"     title="Enable drag mode for shapes">Drag Mode</button>
    <button id="btn-finish"   title="Disable edit/drag modes">Finish Edit</button>

    <span class="spacer"></span>

    <button id="btn-sv-center" title="Open Street View at map centre">Street View here</button>
    <button id="btn-sv-pin" title="Open Street View at last pin">Street View at Pin</button>

    <span class="spacer"></span>

    <!-- Car routing -->
    <input id="route-start" class="mini" type="text" placeholder="Start: address / 52.6,-2.7 / 349000,306000" />
    <input id="route-end"   class="mini" type="text" placeholder="End: address / 52.7,-2.8 / 340000,300000" />
    <button id="btn-pin-start" title="Use current pin as Start">Pin→Start</button>
    <button id="btn-pin-end" title="Use current pin as End">Pin→End</button>
    <button id="btn-swap" title="Swap start/end">Swap</button>
    <button id="btn-route" title="Calculate routes">Route</button>
    <button id="btn-clear-route" title="Clear routes">Clear</button>
    <label title="Use Google Directions"><input type="checkbox" id="use-google" checked> Use Google</label>
  </div>

  <div class="bottom-dock" id="bottom-dock">
    <div class="card metrics" id="metrics">
      <h4>DRAWN POLYGON INFORMATION:</h4>
      <div class="row">Type: <code id="m-type">—</code></div>
      <div class="row">Area: <code id="m-area">—</code></div>
      <div class="row">Perimeter: <code id="m-perim">—</code></div>
      <div class="row">Longest edge: <code id="m-longest">—</code></div>
      <div class="row" style="margin-top:8px;">
        <button id="btn-copy" class="btn">Copy Coords</button>
        <button id="btn-center-shape" class="btn">Center on Shape</button>
      </div>
    </div>

    <div class="card routebox" id="routebox">
      <h4>ROUTES (Car):</h4>
      <div class="row">Vias (Ctrl+Click to add): <span id="vias"></span> <button id="clear-vias" class="btn">Clear vias</button></div>
      <div id="r-list" class="row"></div>
      <div class="row" style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
        <button id="btn-use-selected" class="btn">Use Selected</button>
        <button id="btn-copy-selected" class="btn">Copy Coords</button>
        <button id="btn-zoom-all" class="btn">Zoom All</button>
      </div>
      <div class="row" style="opacity:.8">Road‑true geometry. Press <b>P</b> to toggle dock. Right‑click: set Start/End, Ctrl+Click: add a Via.</div>
    </div>

    <div class="card infobox" id="info">
      <h4>LOCATION INFORMATION:</h4>
      <div class="row">Postcode: <code id="postcode">—</code></div>
      <div class="row">Lat/Lon: <code id="latlon">—</code></div>
      <div class="row">Easting/Northing: <code id="en">—</code></div>
      <div class="row" style="opacity:.8">Shift+Click: drop pin • Ctrl+Click: add via • Alt+Click: Street View • Right‑click: set Start/End</div>
    </div>
  </div>

  <div id="sv-panel">
    <div id="sv-header">
      <div id="sv-title">Street View</div>
      <div id="sv-actions">
        <button id="sv-popout" title="Open in Google Maps">Open in Maps</button>
        <button id="sv-close" title="Close Street View">Close</button>
      </div>
    </div>
    <div id="pano"></div>
  </div>
</div>

<script id="gmaps-loader">
(function () {
  const STORAGE = 'gmapsApiKey';
  const paramKey = new URL(location.href).searchParams.get('gmaps');
  if (paramKey) localStorage.setItem(STORAGE, paramKey);
  const savedKey = localStorage.getItem(STORAGE);
  function inject(k) {
    if (!k) return;
    const s = document.createElement('script');
    s.src = 'https://maps.googleapis.com/maps/api/js?key=' + encodeURIComponent(k) + '&v=weekly&loading=async';
    s.async = true; s.defer = true;
    document.head.appendChild(s);
  }
  if (savedKey) { inject(savedKey); return; }
  const ui = document.createElement('div');
  ui.style.cssText = 'position:fixed;z-index:2000;left:50%;top:12px;transform:translateX(-50%);background:#fff;padding:10px 12px;border:1px solid #ddd;border-radius:10px;box-shadow:0 2px 12px rgba(0,0,0,.15);font:13px system-ui';
  ui.innerHTML = `
    <b>Google Maps API key needed</b>
    <div style="margin-top:6px;display:flex;gap:6px;align-items:center;">
      <input id="gmaps-key-input" type="password" placeholder="Paste key…" style="width:280px;padding:6px 8px;border:1px solid #ccc;border-radius:8px;">
      <button id="gmaps-key-save" style="padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#f7f7f7;cursor:pointer;">Save</button>
      <button id="gmaps-key-cancel" style="padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer;">Dismiss</button>
    </div>
    <div style="margin-top:6px;opacity:.75">Or use <code>?gmaps=YOUR_KEY</code>. Stored only in this browser.</div>`;
  document.addEventListener('DOMContentLoaded', () => {
    document.body.appendChild(ui);
    document.getElementById('gmaps-key-save')?.addEventListener('click', () => {
      const val = document.getElementById('gmaps-key-input').value.trim();
      if (!val) return alert('Paste your Google Maps JavaScript API key.');
      localStorage.setItem(STORAGE, val); ui.remove(); inject(val);
    });
    document.getElementById('gmaps-key-cancel')?.addEventListener('click', () => ui.remove());
  });
  window.__clearGMapsKey = () => { localStorage.removeItem(STORAGE); location.reload(); };
})();
</script>

<script type="module">
  const centre = [52.677027, -2.773167];
  proj4.defs('EPSG:27700', '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs');
  const WGS84 = 'EPSG:4326', OSGB='EPSG:27700';
  const byId = id => document.getElementById(id);
  const isNum = v => typeof v === 'number' && isFinite(v) && !isNaN(v);

  const bottomDock = byId('bottom-dock');
  byId('toggle-panels').onclick = () => { bottomDock.style.display = (bottomDock.style.display==='none' ? 'flex' : 'none'); };
  document.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='p') byId('toggle-panels').click(); });

  const esriImagery = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {maxZoom:20, attribution:"Imagery © Esri"});
  const esriLabels  = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}", {maxZoom:20, attribution:"Labels © Esri"});
  const osmStreets  = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {maxZoom:20, attribution:"© OpenStreetMap contributors"});

  const map = L.map("map", { center: centre, zoom: 19, layers: [esriImagery, esriLabels], fullscreenControl: true });

  function blockEventsFor(selector) {
    document.querySelectorAll(selector).forEach(el => { L.DomEvent.disableClickPropagation(el); L.DomEvent.disableScrollPropagation(el); });
  }
  blockEventsFor('#ui-toolbar, #bottom-dock, #sv-panel, .leaflet-control-container');

  let pin = L.marker(centre).addTo(map).bindPopup("SY3 0NS").openPopup();

  async function ensureGoogle() {
    for (let i=0;i<400;i++) { if (window.google?.maps?.importLibrary) break; await new Promise(r=>setTimeout(r,25)); }
    if (!window.google?.maps?.importLibrary) throw new Error('Google Maps JS API not ready');
    await google.maps.importLibrary("maps");
  }
  try {
    await ensureGoogle();
    const gRoad = L.gridLayer.googleMutant({ type: "roadmap", maxZoom: 21 });
    const gHybrid = L.gridLayer.googleMutant({ type: "hybrid", maxZoom: 21 });
    const gSat = L.gridLayer.googleMutant({ type: "satellite", maxZoom: 21 });
    map.addLayer(gHybrid);
    const baseMaps = { "Google Roadmap": gRoad, "Google Hybrid": gHybrid, "Google Satellite": gSat, "Esri Satellite (fallback)": esriImagery, "OSM Streets (fallback)": osmStreets };
    const overlays = { "Esri Labels (for Esri Hybrid)": esriLabels };
    L.control.layers(baseMaps, overlays, { collapsed: false }).addTo(map);
  } catch (e) {
    console.warn('Google base unavailable', e);
    L.control.layers({ "Esri Satellite": esriImagery, "OSM Streets": osmStreets }, { "Esri Labels (Hybrid)": esriLabels }, { collapsed: false }).addTo(map);
  }

  const elPostcode = byId('postcode'), elLatLon = byId('latlon'), elEN = byId('en');
  function normalizeUKPostcode(str){ if(!str) return null; const s=str.toUpperCase().replace(/\s+/g,''); return /^[A-Z]{1,2}\d[A-Z\d]?\d[A-Z]{2}$/.test(s)?s:null; }
  async function updateInfo(lat,lon){
    const latStr=lat.toFixed(6), lonStr=lon.toFixed(6);
    elLatLon.textContent=`${latStr}, ${lonStr}`;
    const [E,N]=proj4(WGS84,OSGB,[lon,lat]); elEN.textContent=`${Math.round(E)}, ${Math.round(N)}`;
    let pc='—'; try{ const pr=await fetch(`https://api.postcodes.io/postcodes?lon=${lonStr}&lat=${latStr}&limit=1`); const pj=await pr.json(); pc=pj?.result?.[0]?.postcode||'—'; }catch{}
    elPostcode.textContent=pc; pin.setPopupContent(pc);
  }
  function setPin(lat,lon,recenter=false){ if(!isNum(lat)||!isNum(lon)) return; pin.setLatLng([lat,lon]).addTo(map).openPopup(); if(recenter) map.setView([lat,lon], Math.max(map.getZoom(),18)); updateInfo(lat,lon); }

  map.pm.setGlobalOptions({ snappable:true, snapDistance:20, allowSelfIntersection:false, continueDrawing:false, finishOn:'dblclick' });
  map.pm.addControls({ position:"topleft", drawMarker:true, drawPolyline:true, drawRectangle:true, drawPolygon:true, drawCircle:true, drawCircleMarker:true, editMode:true, dragMode:true, cutPolygon:true, removalMode:true });

  // Street View
  let svService=null, panorama=null; const svPanel=byId('sv-panel'), svTitle=byId('sv-title'), svBtnPop=byId('sv-popout');
  function ensureSV(){ if(!window.google||!google.maps) return false; if(!svService) svService=new google.maps.StreetViewService(); if(!panorama) panorama=new google.maps.StreetViewPanorama(byId('pano'),{}); return true; }
  function openSVAt(lat,lon){ if(!ensureSV()) return alert('Google Maps API not ready'); const loc={lat,lng:lon}; svService.getPanorama({location:loc,radius:70},(data,status)=>{ if(status==='OK'&&data?.location){ panorama.setPano(data.location.pano); panorama.setVisible(true); svTitle.textContent='Street View'; svBtnPop.onclick=()=>window.open(`https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${data.location.latLng.lat()},${data.location.latLng.lng()}`,'_blank','noopener'); svPanel.style.display='block'; } else alert('No Street View here.'); }); }
  byId('btn-sv-center').addEventListener('click',()=>{ const c=map.getCenter(); openSVAt(c.lat,c.lng); });
  byId('btn-sv-pin').addEventListener('click',()=>{ const ll=pin.getLatLng(); openSVAt(ll.lat,ll.lng); });
  map.on('contextmenu', e=>{ if(!routeState.start) setRoutePoint('start',e.latlng.lat,e.latlng.lng,'Start'); else setRoutePoint('end',e.latlng.lat,e.latlng.lng,'End'); });

  const routeLayer=L.layerGroup().addTo(map);
  let startMarker=null, endMarker=null;
  const elRS=byId('route-start'), elRE=byId('route-end'), elUseGoogle=byId('use-google');
  const rList=byId('r-list');
  const btnPinStart=byId('btn-pin-start'), btnPinEnd=byId('btn-pin-end'), btnSwap=byId('btn-swap'), btnRoute=byId('btn-route'), btnClearRt=byId('btn-clear-route');
  const btnUseSelected=byId('btn-use-selected'), btnCopySelected=byId('btn-copy-selected'), btnZoomAll=byId('btn-zoom-all');
  const viasWrap=byId('vias'), btnClearVias=byId('clear-vias');

  const routeState={ start:null, end:null, polylines:[], labels:[], meta:[], activeIdx:-1, vias:[], viaMarkers:[] };
  const PALETTE=['#e53935','#43a047','#1e88e5','#8e24aa'];

  async function osrmNearest(lat,lon){
    try{
      const url = `https://router.project-osrm.org/nearest/v1/driving/${lon},${lat}`;
      const j = await fetch(url).then(r=>r.json());
      const loc = j?.waypoints?.[0]?.location;
      if (Array.isArray(loc) && loc.length===2) return { lat: loc[1], lon: loc[0] };
    }catch{}
    return { lat, lon };
  }
  async function snapIfNeeded(obj){ const s=await osrmNearest(obj.lat,obj.lon); return { lat:s.lat, lon:s.lon, label: obj.label }; }

  function renderVias(){
    viasWrap.innerHTML='';
    routeState.vias.forEach((v,i)=>{
      const chip=document.createElement('span'); chip.className='via-chip'; chip.innerHTML=`Via ${i+1} <button title="remove">✕</button>`;
      chip.querySelector('button').onclick=()=>removeVia(i);
      viasWrap.appendChild(chip);
    });
  }
  function addViaPoint(lat,lon, label='via'){
    routeState.vias.push({lat,lon,label});
    const m=L.circleMarker([lat,lon],{radius:6, color:'#7b1fa2', weight:2, fillOpacity:0.6}).addTo(routeLayer).bindTooltip('Via');
    routeState.viaMarkers.push(m);
    renderVias();
  }
  function removeVia(idx){
    routeState.vias.splice(idx,1);
    const m=routeState.viaMarkers.splice(idx,1)[0];
    if(m) routeLayer.removeLayer(m);
    renderVias();
  }

  function setRoutePoint(which, lat, lon, label=''){
    const obj={lat,lon,label};
    const formatted=`${lat.toFixed(6)}, ${lon.toFixed(6)}`;
    if(which==='start'){
      routeState.start=obj;
      elRS.value = label?`${label} (${formatted})`:formatted;
      if(startMarker) startMarker.setLatLng([lat,lon]); else { startMarker=L.marker([lat,lon],{draggable:true}).addTo(routeLayer).bindPopup('Start');
        startMarker.on('dragend',async()=>{ const p=startMarker.getLatLng(); const s=await snapIfNeeded({lat:p.lat,lon:p.lng,label:'Dragged Start'}); routeState.start=s; startMarker.setLatLng([s.lat,s.lon]); elRS.value=`${s.lat.toFixed(6)}, ${s.lon.toFixed(6)}`; }); }
    } else {
      routeState.end=obj;
      elRE.value = label?`${label} (${formatted})`:formatted;
      if(endMarker) endMarker.setLatLng([lat,lon]); else { endMarker=L.marker([lat,lon],{draggable:true}).addTo(routeLayer).bindPopup('End');
        endMarker.on('dragend',async()=>{ const p=endMarker.getLatLng(); const s=await snapIfNeeded({lat:p.lat,lon:p.lng,label:'Dragged End'}); routeState.end=s; endMarker.setLatLng([s.lat,s.lon]); elRE.value=`${s.lat.toFixed(6)}, ${s.lon.toFixed(6)}`; }); }
    }
  }
  byId('btn-pin-start').addEventListener('click',async()=>{ const p=pin.getLatLng(); const s=await snapIfNeeded({lat:p.lat,lon:p.lng,label:'Pin'}); setRoutePoint('start',s.lat,s.lon,'Pin'); });
  byId('btn-pin-end').addEventListener('click',async()=>{ const p=pin.getLatLng(); const s=await snapIfNeeded({lat:p.lat,lon:p.lng,label:'Pin'}); setRoutePoint('end',s.lat,s.lon,'Pin'); });
  byId('btn-swap').addEventListener('click',()=>{ const a=routeState.start, b=routeState.end; routeState.start=b; routeState.end=a; const tmp=elRS.value; elRS.value=elRE.value; elRE.value=tmp; if(startMarker&&b) startMarker.setLatLng([b.lat,b.lon]); if(endMarker&&a) endMarker.setLatLng([a.lat,a.lon]); });

  function clearRoutes(){ routeState.polylines.forEach(pl=>routeLayer.removeLayer(pl)); routeState.labels.forEach(lb=>routeLayer.removeLayer(lb)); routeState.polylines=[]; routeState.labels=[]; routeState.meta=[]; routeState.activeIdx=-1; rList.innerHTML=''; }

  async function fetchOSRM(origin, dest, vias, bearings){
    const coordsArr = [[origin.lon,origin.lat], ...vias.map(v=>[v.lon,v.lat]), [dest.lon,dest.lat]];
    const coords = coordsArr.map(pair=>pair.join(',')).join(';');
    const params = new URLSearchParams({ overview:'full', geometries:'geojson', alternatives:'false', steps:'true' });
    if (Array.isArray(bearings) && bearings.length === coordsArr.length){
      const b = bearings.map(v => v ? `${Math.round(v.angle)},${Math.round(v.range||20)}` : '').join(';');
      params.set('bearings', b);
    }
    const url = `https://router.project-osrm.org/route/v1/driving/${coords}?${params}`;
    const j = await fetch(url).then(r=>r.json()).catch(()=>null);
    if (!j||!j.routes) return null;
    const rt = j.routes[0];
    return { provider:'OSRM', distance:rt.distance, duration:rt.duration,
             coords: rt.geometry.coordinates.map(([lon,lat])=>[lat,lon]) };
  }

  function googleRouteToFullPath(route){
    const pts = [];
    (route.legs||[]).forEach(leg=>{
      (leg.steps||[]).forEach(step=>{
        const path = step.path || [];
        for (let i=0;i<path.length;i++) pts.push([path[i].lat(), path[i].lng()]);
      });
    });
    if (!pts.length && route.overview_path){
      for (const p of route.overview_path) pts.push([p.lat(), p.lng()]);
    }
    return pts;
  }

  async function fetchGoogle(origin, dest, vias){
    if (!window.google?.maps) return null;
    const svc = new google.maps.DirectionsService();
    const req = {
      origin: {lat:origin.lat, lng:origin.lon},
      destination: {lat:dest.lat, lng:dest.lon},
      travelMode: 'DRIVING',
      provideRouteAlternatives: false,
      optimizeWaypoints: false
    };
    if (vias && vias.length){
      req.waypoints = vias.map(v=>({ location:{lat:v.lat, lng:v.lon}, stopover:false }));
    }
    const res = await new Promise(resolve => svc.route(req,(r,st)=>resolve(st==='OK'?r:null)));
    if (!res?.routes?.length) return null;
    const r = res.routes[0];
    const path = googleRouteToFullPath(r);
    let distance=0, duration=0;
    (r.legs||[]).forEach(leg=>{ distance+=(leg.distance?.value||0); duration+=(leg.duration?.value||0); });
    return { provider:'Google', distance, duration, coords: path };
  }

  function hashCoords(coords){ const rounded = coords.map(ll=>[+ll[0].toFixed(5), +ll[1].toFixed(5)]); return JSON.stringify([rounded.length, rounded.slice(0,200)]); }
  function midpointLatLng(latlngs){ return latlngs[Math.floor(latlngs.length/2)]; }
  function makeNumberBadge(n,color,at){ const icon=L.divIcon({ className:'route-badge', html:`<div style="background:${color};color:#fff;border-radius:50%;width:22px;height:22px;display:flex;align-items:center;justify-content:center;font:12px/22px system-ui;box-shadow:0 1px 4px rgba(0,0,0,.25);">${n}</div>`, iconSize:[22,22], iconAnchor:[11,11] }); return L.marker(at,{icon}); }

  function setActiveRoute(idx){
    routeState.activeIdx=idx;
    routeState.polylines.forEach((pl,i)=>{
      pl.setStyle({weight: i===idx?6:4, opacity: i===idx?0.98:0.7, dashArray: i===idx?null:'6,6'});
      if (i===idx && pl.bringToFront) pl.bringToFront();
    });
    const items = Array.from(rList.querySelectorAll('.route-item'));
    items.forEach((el,i)=> el.classList.toggle('active', i===idx));
    if(idx>=0 && routeState.polylines[idx]) map.fitBounds(routeState.polylines[idx].getBounds(), {padding:[30,30]});
  }

  function addRouteToUI(coords, meta, paletteIndex){
    const color = PALETTE[paletteIndex % PALETTE.length];
    const poly=L.polyline(coords,{color,weight:4,opacity:0.98}).addTo(routeLayer);
    const mid=midpointLatLng(coords); const badge=makeNumberBadge(routeState.polylines.length+1,color,mid).addTo(routeLayer);

    const km=(meta.distance/1000).toFixed(2);
    const mins=Math.round(meta.duration/60); const hrs=Math.floor(mins/60), rem=mins%60; const durTxt=hrs?`${hrs}h ${rem}m`:`${mins} min`;

    const idx = routeState.polylines.length;
    const item=document.createElement('div'); item.className='route-item';
    item.innerHTML=`<div class="route-swatch" style="background:${color}"></div>
      <div><b>${idx+1}.</b> ${km} km • ${durTxt}
      <span class="provider-tag">${meta.provider}</span></div>`;
    item.onclick=()=>setActiveRoute(idx);
    poly.on('click',()=>setActiveRoute(idx));

    rList.appendChild(item);
    routeState.polylines.push(poly);
    routeState.labels.push(badge);
    routeState.meta.push({...meta, color});
  }

  async function resolvePoint(text){
    const raw=(text||'').trim(); if(!raw) return null;
    const parts=raw.replace(/[()]/g,'').split(/[,\s]+/).filter(Boolean);
    if(parts.length===2 && !isNaN(+parts[0]) && !isNaN(+parts[1])){
      const a=+parts[0], b=+parts[1];
      if(Math.abs(a)>1000 && Math.abs(b)>1000){ const [lon,lat]=proj4(OSGB,WGS84,[a,b]); return await snapIfNeeded({lat,lon,label:'E/N'}); }
      if(Math.abs(a)<=90 && Math.abs(b)<=180){ return await snapIfNeeded({lat:a,lon:b,label:'Lat/Lon'}); }
    }
    const maybePC=normalizeUKPostcode(raw);
    if(maybePC){ try{ const r=await fetch(`https://api.postcodes.io/postcodes/${maybePC}`); const j=await r.json(); if(j?.status===200&&j.result) return await snapIfNeeded({lat:j.result.latitude, lon:j.result.longitude, label:j.result.postcode}); }catch{} }
    try{
      const url=`https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(raw)}&countrycodes=gb&limit=1&accept-language=en-GB`;
      const r=await fetch(url,{headers:{'Accept':'application/json'}}); const j=await r.json();
      if(j&&j.length) return await snapIfNeeded({lat:+j[0].lat, lon:+j[0].lon, label:(j[0].display_name||'').split(',')[0]||'Address'});
    }catch{}
    return null;
  }

  function toRad(d){ return d*Math.PI/180; }
  function toDeg(r){ return r*180/Math.PI; }
  function destPoint(lat, lon, headingDeg, meters){
    const R=6371000, brng=toRad(headingDeg), d=meters;
    const lat1=toRad(lat), lon1=toRad(lon);
    const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d/R) + Math.cos(lat1)*Math.sin(d/R)*Math.cos(brng));
    const lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(lat1), Math.cos(d/R)-Math.sin(lat1)*Math.sin(lat2));
    return { lat: toDeg(lat2), lon: ((toDeg(lon2)+540)%360)-180 };
  }
  function bearingDegrees(from, to){
    const φ1=toRad(from.lat), φ2=toRad(to.lat);
    const λ1=toRad(from.lon), λ2=toRad(to.lon);
    const y=Math.sin(λ2-λ1)*Math.cos(φ2);
    const x=Math.cos(φ1)*Math.sin(φ2)-Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
    return (toDeg(Math.atan2(y,x))+360)%360;
  }

  async function makeLockedDirectionVias(end, start){
    const baseBear = bearingDegrees(end, start);
    const f1raw = destPoint(end.lat, end.lon,  baseBear, 80);
    const f2raw = destPoint(end.lat, end.lon,  baseBear, 260);
    const b1raw = destPoint(end.lat, end.lon, (baseBear+180)%360, 120);
    const b2raw = destPoint(end.lat, end.lon, (baseBear+180)%360, 380);
    const f1 = await snapIfNeeded(f1raw);
    const f2 = await snapIfNeeded(f2raw);
    const b1 = await snapIfNeeded(b1raw);
    const b2 = await snapIfNeeded(b2raw);
    return { baseBear, forwardVias:[f1,f2], backwardVias:[b1,b2] };
  }

  async function planTwoWayLocked(){
    if(!routeState.start){ const s=await resolvePoint(elRS.value); if(!s) return alert('Set a valid Start.'); setRoutePoint('start',s.lat,s.lon,s.label); }
    if(!routeState.end){   const e=await resolvePoint(elRE.value); if(!e) return alert('Set a valid End.');   setRoutePoint('end',e.lat,e.lon,e.label); }
    routeState.start = await snapIfNeeded(routeState.start);
    routeState.end   = await snapIfNeeded(routeState.end);
    const START = routeState.start;
    const END   = routeState.end;
    clearRoutes();
    const { baseBear, forwardVias, backwardVias } = await makeLockedDirectionVias(END, START);
    const origin = END, dest = START;
    const results = [];
    const osrmF = await fetchOSRM(origin, dest, forwardVias, [{angle: baseBear, range: 20}, {angle: baseBear, range: 25}, null, null]);
    if (osrmF) results.push(osrmF);
    const backAngle = (baseBear+180)%360;
    const osrmB = await fetchOSRM(origin, dest, backwardVias, [{angle: backAngle, range: 20}, {angle: backAngle, range: 25}, null, null]);
    if (osrmB) results.push(osrmB);
    if (elUseGoogle.checked){
      const gF = await fetchGoogle(origin, dest, forwardVias);
      if (gF) results.push(gF);
      const gB = await fetchGoogle(origin, dest, backwardVias);
      if (gB) results.push(gB);
    }
    if (!results.length){ alert('No routes found. Try nudging the END closer to the carriageway.'); return; }
    const byProv = { OSRM:[], Google:[] };
    for (const r of results) byProv[r.provider]?.push(r);
    for (const k of Object.keys(byProv)) byProv[k].sort((a,b)=>a.duration-b.duration);
    const finalRoutes = [...byProv.OSRM.slice(0,2), ...byProv.Google.slice(0,2)].filter(Boolean);
    const seen = new Set(); let paletteIndex=0;
    for (const rt of finalRoutes){
      const key = rt.provider[0] + ':' + hashCoords(rt.coords);
      if (seen.has(key)) continue;
      seen.add(key);
      addRouteToUI(rt.coords, {provider:rt.provider, distance:rt.distance, duration:rt.duration}, paletteIndex++);
    }
    if (routeState.polylines.length) setActiveRoute(0);
  }

  function getActiveRouteCoords(){ const idx=routeState.activeIdx; if(idx==null||idx<0) return null; const pl=routeState.polylines[idx]; if(!pl) return null; const latlngs=pl.getLatLngs(); return Array.isArray(latlngs[0])?latlngs.flat():latlngs; }
  byId('btn-use-selected').addEventListener('click',()=>{ const pts=getActiveRouteCoords(); if(!pts||!pts.length) return alert('Select a route first.'); const poly=L.polyline(pts,{color:'#007ACC',weight:3,opacity:0.98}).addTo(map); if(poly.pm&&poly.pm.enable) poly.pm.enable({snappable:true,snapDistance:20}); });
  byId('btn-copy-selected').addEventListener('click', async ()=>{ const pts=getActiveRouteCoords(); if(!pts||!pts.length) return alert('Select a route first.'); const coords=pts.map(ll=>[ll.lng,ll.lat]); const text=JSON.stringify(coords); if(navigator.clipboard?.writeText) await navigator.clipboard.writeText(text); else { const ta=document.createElement('textarea'); ta.value=text; ta.style.position='fixed'; ta.style.top='-9999px'; document.body.appendChild(ta); ta.focus(); ta.select(); document.execCommand('copy'); ta.remove(); } });
  byId('btn-zoom-all').addEventListener('click',()=>{
    const groups = routeState.polylines.filter(Boolean);
    if(!groups.length) return;
    let bounds = groups[0].getBounds();
    groups.slice(1).forEach(pl => bounds = bounds.extend(pl.getBounds()));
    map.fitBounds(bounds, {padding:[30,30]});
  });

  byId('btn-route').addEventListener('click', ()=>{ planTwoWayLocked(); });
  byId('btn-clear-route').addEventListener('click', ()=>{ clearRoutes(); });
  (async()=>{ await updateInfo(centre[0], centre[1]); })();
</script>

<noscript>Enable JavaScript to view the map.</noscript>
</body>
</html>
