<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <title>Leaflet + Google + Unified UK Search + Draw + Edit + Metrics</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Fullscreen -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.css">
  <script src="https://unpkg.com/leaflet.fullscreen@2.4.0/Control.FullScreen.js"></script>

  <!-- Leaflet.Geoman (drawing/editing) -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.css">
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.15.0/dist/leaflet-geoman.min.js"></script>

  <!-- GoogleMutant (Leaflet grid layer for Google) -->
  <script src="https://unpkg.com/leaflet.gridlayer.googlemutant@0.15.0/dist/Leaflet.GoogleMutant.js"></script>

  <!-- Leaflet Control Geocoder (Nominatim) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css">
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <!-- Proj4 for OSGB36 <-> WGS84 transforms -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.1/proj4.min.js"></script>

  <!-- Turf.js for area/perimeter -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { width: 100%; height: 100vh; position: relative; }

    /* One-line toolbar: no-wrap, full width, horizontal scroll on overflow */
    .toolbar {
      position: absolute; z-index: 1000; top: 10px; left: 60px; right: 10px;
      background: #fff; border-radius: 12px; padding: 8px 10px;
      box-shadow: 0 2px 12px rgba(0,0,0,.18); font: 14px system-ui, sans-serif;

      display: flex; align-items: center; gap: 8px;
      flex-wrap: nowrap;               /* <- no wrapping */
      white-space: nowrap;             /* <- keep everything on one line */
      overflow-x: auto; overflow-y: hidden;  /* <- allow horizontal scroll if needed */
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
    }
    .toolbar select, .toolbar input, .toolbar button {
      padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px;
      flex: 0 0 auto; /* prevent flex growing/shrinking unpredictably */
    }
    /* Make the main query field flexible but keep it one-line */
    #q { min-width: 320px; flex: 1 1 420px; }
    .toolbar .spacer { width: 6px; flex: 0 0 auto; }

    /* Info panel (pin details) */
    .info {
      position: absolute; z-index: 1000; right: 10px; bottom: 50px;
      background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif;
      min-width: 280px; max-width: 360px;
    }
    .info h4 { margin: 0 0 6px 0; font-size: 14px; }
    .info .row { margin: 4px 0; }
    .info code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }

    /* Polygon metrics panel */
    .metrics {
      position: absolute; z-index: 1000; left: 10px; bottom: 50px;
      background: #fff; border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.18); font: 13px system-ui, sans-serif;
      min-width: 260px; max-width: 360px;
    }
    .metrics h4 { margin: 0 0 6px 0; font-size: 14px; }
    .metrics .row { margin: 4px 0; }
    .metrics code { background: #fafafa; padding: 1px 4px; border-radius: 4px; }

    /* Keep one line even on small screens; user can horizontal-scroll the bar */
    @media (max-width: 640px) {
      #q { min-width: 260px; flex-basis: 300px; }
    }
  </style>
</head>
<body>
<div id="map">
  <!-- Unified Search + Drawing toolbar (single line) -->
  <div class="toolbar">
    <select id="mode" title="Search mode">
      <option value="postcode">Postcode / Address</option>
      <option value="latlon">Lat, Lon</option>
      <option value="en">Easting, Northing</option>
    </select>

    <input id="q" type="text"
           placeholder="SY3 0NS  |  52.677027, -2.773167  |  349000, 306000" />

    <button id="go">Search</button>

    <span class="spacer"></span>

    <button id="btn-export" title="Download drawings as GeoJSON">Export</button>
    <button id="btn-import" title="Load drawings from GeoJSON">Import</button>
    <input id="file-import" type="file" accept=".json,.geojson" style="display:none">

    <span class="spacer"></span>

    <button id="btn-edit-all" title="Enable edit mode for all shapes">Edit All</button>
    <button id="btn-drag"     title="Enable drag mode for shapes">Drag Mode</button>
    <button id="btn-finish"   title="Disable edit/drag modes">Finish Edit</button>
  </div>

  <!-- Pin info panel -->
  <div class="info" id="info">
    <h4>Pin info</h4>
    <div class="row" id="addr">Address: <em>—</em></div>
    <div class="row">Lat/Lon: <code id="latlon">—</code></div>
    <div class="row">Easting/Northing: <code id="en">—</code></div>
    <div class="row" style="opacity:.8">Tip: Click a polygon to edit its vertices. Shift+click adds a vertex, right-click removes (while in edit mode).</div>
  </div>

  <!-- Polygon metrics panel -->
  <div class="metrics" id="metrics">
    <h4>Shape info</h4>
    <div class="row">Type: <code id="m-type">—</code></div>
    <div class="row">Area: <code id="m-area">—</code></div>
    <div class="row">Perimeter: <code id="m-perim">—</code></div>
  </div>
</div>

<!-- Google Maps JS (async, no callback) -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAdHcFCZWzjEOj98oEn5AfufQMR0p9VgLA&v=weekly&loading=async"></script>

<script type="module">
  // ---------- Config ----------
  const centre = [52.677027, -2.773167]; // 29 Green Lane, SY3 0NS
  proj4.defs('EPSG:27700', '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs');
  const WGS84 = 'EPSG:4326';
  const OSGB  = 'EPSG:27700';

  const byId = id => document.getElementById(id);
  const isNum = v => typeof v === 'number' && isFinite(v) && !isNaN(v);

  // ---------- Basemaps ----------
  const esriImagery = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 20, attribution: "Imagery © Esri" }
  );
  const esriLabels = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 20, attribution: "Labels © Esri" }
  );
  const osmStreets = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    { maxZoom: 20, attribution: "© OpenStreetMap contributors" }
  );

  // Map init with fallback
  const map = L.map("map", {
    center: centre,
    zoom: 19,
    layers: [esriImagery, esriLabels],
    fullscreenControl: true
  });

  // Initial pin
  let pin = L.marker(centre).addTo(map).bindPopup("29 Green Lane, SY3 0NS").openPopup();

  // Optional map-embedded geocoder control
  L.Control.geocoder({ defaultMarkGeocode: false, placeholder: 'Search…' })
    .on('markgeocode', e => {
      const { center, name, bbox } = e.geocode;
      setPin(center.lat, center.lng, name);
      if (bbox) map.fitBounds(bbox);
    })
    .addTo(map);

  // Pin info panel
  const elAddr = byId('addr');
  const elLatLon = byId('latlon');
  const elEN = byId('en');

  async function updateInfo(lat, lon, labelHint = '') {
    const latStr = lat.toFixed(6), lonStr = lon.toFixed(6);
    elLatLon.textContent = `${latStr}, ${lonStr}`;

    const [E, N] = proj4(WGS84, OSGB, [lon, lat]);
    elEN.textContent = `${Math.round(E)}, ${Math.round(N)}`;

    try {
      const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latStr}&lon=${lonStr}&addressdetails=1&zoom=18&accept-language=en-GB`;
      const resp = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const data = await resp.json();
      const addr = data?.display_name || labelHint || 'Unknown location';
      elAddr.innerHTML = `Address: <em>${addr}</em>`;
      pin.setPopupContent(addr);
    } catch {
      elAddr.innerHTML = `Address: <em>${labelHint || 'Lookup failed'}</em>`;
    }
  }

  function setPin(lat, lon, labelHint = '') {
    if (!isNum(lat) || !isNum(lon)) return;
    pin.setLatLng([lat, lon]);
    pin.addTo(map).openPopup();
    map.setView([lat, lon], Math.max(map.getZoom(), 18));
    updateInfo(lat, lon, labelHint);
  }

  map.on('click', e => setPin(e.latlng.lat, e.latlng.lng, 'Dropped pin'));

  // ---------- Google base (async ready) ----------
  async function ensureGoogle() {
    for (let i = 0; i < 400; i++) {
      if (window.google?.maps?.importLibrary) break;
      await new Promise(r => setTimeout(r, 25));
    }
    if (!window.google?.maps?.importLibrary) throw new Error('Google Maps JS API not ready');
    await google.maps.importLibrary("maps");
  }

  try {
    await ensureGoogle();
    const gRoad   = L.gridLayer.googleMutant({ type: "roadmap",   maxZoom: 21 });
    const gHybrid = L.gridLayer.googleMutant({ type: "hybrid",    maxZoom: 21 });
    const gSat    = L.gridLayer.googleMutant({ type: "satellite", maxZoom: 21 });

    map.addLayer(gHybrid); // default to Hybrid

    const baseMaps = {
      "Google Roadmap": gRoad,
      "Google Hybrid":  gHybrid,
      "Google Satellite": gSat,
      "Esri Satellite (fallback)": esriImagery,
      "OSM Streets (fallback)": osmStreets
    };
    const overlays = { "Esri Labels (for Esri Hybrid)": esriLabels };
    L.control.layers(baseMaps, overlays, { collapsed: false }).addTo(map);

  } catch (e) {
    console.warn('Google base unavailable, staying on Esri/OSM.', e);
    L.control.layers(
      { "Esri Satellite": esriImagery, "OSM Streets": osmStreets },
      { "Esri Labels (Hybrid)": esriLabels },
      { collapsed: false }
    ).addTo(map);
  }

  // ---------- Unified Search ----------
  byId('mode').addEventListener('change', () => {
    const m = byId('mode').value;
    byId('q').placeholder =
      m === 'postcode' ? 'SY3 0NS  |  10 Downing Street' :
      m === 'latlon'   ? '52.677027, -2.773167' :
                         '349000, 306000';
  });

  byId('go').addEventListener('click', runUnifiedSearch);
  byId('q').addEventListener('keydown', e => { if (e.key === 'Enter') runUnifiedSearch(); });

  async function runUnifiedSearch() {
    const mode = byId('mode').value;
    const raw  = byId('q').value.trim();
    if (!raw) return;

    if (mode === 'latlon') {
      const parts = raw.split(/[,\s]+/).filter(Boolean);
      if (parts.length !== 2) return alert('Use: 52.677027, -2.773167');
      const lat = parseFloat(parts[0]), lon = parseFloat(parts[1]);
      if (!isNum(lat) || !isNum(lon)) return alert('Invalid lat/lon.');
      setPin(lat, lon, 'Lat/Lon'); return;
    }

    if (mode === 'en') {
      const parts = raw.split(/[,\s]+/).filter(Boolean);
      if (parts.length !== 2) return alert('Use: 349000, 306000 (E,N)');
      const E = parseFloat(parts[0]), N = parseFloat(parts[1]);
      if (!isNum(E) || !isNum(N)) return alert('Invalid Easting/Northing.');
      const [lon, lat] = proj4(OSGB, WGS84, [E, N]);
      setPin(lat, lon, `OSGB36: ${Math.round(E)}, ${Math.round(N)}`); return;
    }

    try {
      const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(raw)}&countrycodes=gb&limit=1&addressdetails=1&accept-language=en-GB`;
      const r = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const j = await r.json();
      if (j && j.length) {
        const { lat, lon, display_name, boundingbox } = j[0];
        setPin(parseFloat(lat), parseFloat(lon), display_name);
        if (boundingbox) {
          const bb = [[+boundingbox[0], +boundingbox[2]],[+boundingbox[1], +boundingbox[3]]];
          map.fitBounds(bb, { maxZoom: 19 });
        }
      } else alert('No results.');
    } catch { alert('Search failed (network or rate limit).'); }
  }

  // ---------- Export / Import ----------
  byId('btn-export').onclick = () => {
    const feats = [];
    map.eachLayer(l => {
      if (l.pm && l.toGeoJSON) {
        const gj = l.toGeoJSON();
        if (gj.type === 'Feature') feats.push(gj);
        else if (gj.type === 'FeatureCollection') feats.push(...gj.features);
      }
    });
    const fc = { type: 'FeatureCollection', features: feats };
    const blob = new Blob([JSON.stringify(fc, null, 2)], { type: 'application/json' });
    const a = Object.assign(document.createElement('a'), {
      href: URL.createObjectURL(blob), download: 'drawings.geojson'
    });
    a.click(); URL.revokeObjectURL(a.href);
  };

  byId('btn-import').onclick = () => byId('file-import').click();
  byId('file-import').onchange = async ev => {
    const file = ev.target.files[0]; if (!file) return;
    try {
      const text = await file.text();
      const gj = JSON.parse(text);
      const layerGroup = L.geoJSON(gj, { style: defaultStyle }).addTo(map);
      try { map.fitBounds(layerGroup.getBounds(), { maxZoom: 19 }); } catch {}
      layerGroup.eachLayer(l => bindEditableHandlers(l, true));
    } catch { alert('Invalid GeoJSON.'); }
  };

  // ---------- Geoman drawing & EDITING + Metrics ----------
  const defaultStyle = { color: "#00AEEF", weight: 2, fillOpacity: 0.18 };
  const activeStyle  = { color: "#007ACC", weight: 2, fillOpacity: 0.20 };

  map.pm.setGlobalOptions({
    snappable: true,
    snapDistance: 20,
    allowSelfIntersection: false,
    continueDrawing: false
  });

  map.pm.addControls({
    position: "topleft",
    drawMarker: true,
    drawPolyline: true,
    drawRectangle: true,
    drawPolygon: true,
    drawCircle: true,
    drawCircleMarker: true,
    editMode: true,
    dragMode: true,
    cutPolygon: true,
    removalMode: true
  });

  let selectedLayer = null;
  const mType  = byId('m-type');
  const mArea  = byId('m-area');
  const mPerim = byId('m-perim');

  function updateMetrics(layer) {
    if (!layer) { mType.textContent='—'; mArea.textContent='—'; mPerim.textContent='—'; return; }
    if (layer instanceof L.Circle) {
      const r = layer.getRadius();
      const area = Math.PI * r * r;
      const peri = 2 * Math.PI * r;
      mType.textContent = 'Circle';
      mArea.textContent = `${area.toFixed(0)} m²  (${(area/10000).toFixed(4)} ha)`;
      mPerim.textContent = `${peri.toFixed(2)} m`;
      return;
    }
    try {
      const gj = layer.toGeoJSON();
      const type = gj.geometry?.type || 'Feature';
      mType.textContent = type;
      if (type === 'Polygon' || type === 'MultiPolygon') {
        const area = turf.area(gj);
        const outline = turf.polygonToLine(gj);
        const lengthKm = turf.length(outline, { units: 'kilometers' });
        const peri = lengthKm * 1000;
        mArea.textContent = `${area.toFixed(0)} m²  (${(area/10000).toFixed(4)} ha)`;
        mPerim.textContent = `${peri.toFixed(2)} m`;
      } else if (type === 'LineString' || type === 'MultiLineString') {
        const lengthKm = turf.length(gj, { units: 'kilometers' });
        mArea.textContent = `—`;
        mPerim.textContent = `${(lengthKm*1000).toFixed(2)} m`;
      } else {
        mArea.textContent = `—`; mPerim.textContent = `—`;
      }
    } catch { mType.textContent='—'; mArea.textContent='—'; mPerim.textContent='—'; }
  }

  function setSelected(layer) {
    if (selectedLayer && selectedLayer.setStyle) selectedLayer.setStyle(defaultStyle);
    selectedLayer = layer;
    if (selectedLayer && selectedLayer.setStyle) selectedLayer.setStyle(activeStyle);
    updateMetrics(selectedLayer);
  }

  function bindEditableHandlers(layer, isImported = false) {
    if (layer.setStyle && !isImported) layer.setStyle(defaultStyle);
    layer.on('click', () => {
      setSelected(layer);
      if (layer.pm) {
        if (layer.pm.enabled()) layer.pm.disable();
        else layer.pm.enable({ allowSelfIntersection: false, snappable: true, snapDistance: 20 });
      }
    });
    layer.on('pm:edit',   () => updateMetrics(layer));
    layer.on('pm:dragend',() => updateMetrics(layer));
    layer.on('pm:enable', () => { if (layer.setStyle) layer.setStyle(activeStyle); });
    layer.on('pm:disable',() => { if (layer.setStyle) layer.setStyle(defaultStyle); updateMetrics(layer); });
    updateMetrics(layer);
  }

  map.on("pm:create", e => {
    const layer = e.layer;
    if (layer.setStyle) layer.setStyle(defaultStyle);
    if (layer.pm && layer.pm.enable) {
      layer.pm.enable({ allowSelfIntersection: false, snappable: true, snapDistance: 20 });
    }
    bindEditableHandlers(layer);
    setSelected(layer);
    console.log("Created feature:", layer.toGeoJSON());
  });

  map.eachLayer(l => { if (l.pm) bindEditableHandlers(l); });

  byId('btn-edit-all').onclick = () => { map.pm.toggleGlobalEditMode(); };
  byId('btn-drag').onclick     = () => { map.pm.toggleGlobalDragMode(); };
  byId('btn-finish').onclick   = () => {
    if (map.pm.globalEditEnabled()) map.pm.toggleGlobalEditMode();
    if (map.pm.globalDragModeEnabled && map.pm.globalDragModeEnabled()) map.pm.toggleGlobalDragMode();
    map.eachLayer(l => { if (l.pm && l.pm.enabled && l.pm.enabled()) l.pm.disable(); });
    if (selectedLayer) updateMetrics(selectedLayer);
  };

  // Initial pin info
  (async () => { await updateInfo(centre[0], centre[1], '29 Green Lane, SY3 0NS'); })();
</script>

<noscript>Enable JavaScript to view the map.</noscript>
</body>
</html>
